<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="蒋正义的修炼之路">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="蒋正义的修炼之路">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蒋正义的修炼之路">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>蒋正义的修炼之路</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒋正义的修炼之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/工厂模式/" itemprop="url">工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T14:55:40+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h2><p>工厂模式提供了一种不用暴露创建逻辑来创建对象的方法。它包含两个类型：</p>
<p><img src="/2019/11/19/工厂模式/factory_strategy.png" alt=""></p>
<ol>
<li>factory创建对象</li>
<li>product就是被创建的对象</li>
</ol>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>根据求职者来生产求职回信对象</p>
<h3 id="1-定义JobApplicant和Email模型"><a href="#1-定义JobApplicant和Email模型" class="headerlink" title="1.定义JobApplicant和Email模型"></a>1.定义JobApplicant和Email模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public struct JobApplicant &#123;</div><div class="line">  public let name: String</div><div class="line">  public let email: String</div><div class="line">  public var status: Status</div><div class="line">  </div><div class="line">  public enum Status &#123;</div><div class="line">    case new</div><div class="line">    case interview</div><div class="line">    case hired</div><div class="line">    case rejected</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public struct Email &#123;</div><div class="line">  public let subject: String</div><div class="line">  public let messageBody: String</div><div class="line">  public let recipientEmail: String</div><div class="line">  public let senderEmail: String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-创建工厂结构"><a href="#2-创建工厂结构" class="headerlink" title="2.创建工厂结构"></a>2.创建工厂结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public struct EmailFactory &#123;</div><div class="line">  </div><div class="line">  public let senderEmail: String</div><div class="line">  </div><div class="line">  public func createEmail(to recipient: JobApplicant) -&gt; Email &#123;</div><div class="line">    switch recipient.status &#123;</div><div class="line">    case .new:</div><div class="line">      return Email(</div><div class="line">        subject: &quot;We Received Your Application&quot;,</div><div class="line">        messageBody: &quot;Thanks for applying for a job here! &quot; +</div><div class="line">        &quot;You should hear from us in 17-42 business days.&quot;,</div><div class="line">        recipientEmail: recipient.email,</div><div class="line">        senderEmail: senderEmail)</div><div class="line">      </div><div class="line">    case .interview:</div><div class="line">      return Email(</div><div class="line">        subject: &quot;We Want to Interview You&quot;,</div><div class="line">        messageBody: &quot;Thanks for your resume, \(recipient.name)! &quot; +</div><div class="line">        &quot;Can you come in for an interview in 30 minutes?&quot;,</div><div class="line">        recipientEmail: recipient.email,</div><div class="line">        senderEmail: senderEmail)</div><div class="line">      </div><div class="line">    case .hired:</div><div class="line">      return Email(</div><div class="line">        subject: &quot;We Want to Hire You&quot;,</div><div class="line">        messageBody: &quot;Congratulations, \(recipient.name)! &quot; +</div><div class="line">        &quot;We liked your code, and you smelled nice. We want to offer you a position! Cha-ching! $$$&quot;,</div><div class="line">        recipientEmail: recipient.email,</div><div class="line">        senderEmail: senderEmail)</div><div class="line">      </div><div class="line">    case .rejected:</div><div class="line">      return Email(</div><div class="line">        subject: &quot;Thanks for Your Application&quot;,</div><div class="line">        messageBody: &quot;Thank you for applying, \(recipient.name). &quot; +</div><div class="line">          &quot;We have decided to move forward with other candidates. &quot; +</div><div class="line">        &quot;Please remember to wear pants next time!&quot;,</div><div class="line">        recipientEmail: recipient.email,</div><div class="line">        senderEmail: senderEmail)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-使用工厂来创建回信"><a href="#3-使用工厂来创建回信" class="headerlink" title="3.使用工厂来创建回信"></a>3.使用工厂来创建回信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var jackson = JobApplicant(name: &quot;Jackson Smith&quot;,</div><div class="line">                           email: &quot;jackson.smith@example.com&quot;,</div><div class="line">                           status: .new)</div><div class="line"></div><div class="line">let emailFactory = EmailFactory(senderEmail: &quot;RaysMinions@RaysCoffeeCo.com&quot;)</div><div class="line"></div><div class="line">// New</div><div class="line">print(emailFactory.createEmail(to: jackson), &quot;\n&quot;)</div><div class="line"></div><div class="line">// Interview</div><div class="line">jackson.status = .interview</div><div class="line">print(emailFactory.createEmail(to: jackson), &quot;\n&quot;)</div><div class="line"></div><div class="line">// Hired</div><div class="line">jackson.status = .hired</div><div class="line">print(emailFactory.createEmail(to: jackson), &quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>如果你的对象非常简单，你就不需要使用工厂模式</p>
<h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><ol>
<li>3种工厂模式：<a href="https://www.jianshu.com/p/847af218b1f0" target="_blank" rel="external">https://www.jianshu.com/p/847af218b1f0</a></li>
<li>Cocoa中的抽象工厂模式（NSNumber，类簇）:<a href="http://ibloodline.com/articles/2016/09/06/factory.html" target="_blank" rel="external">http://ibloodline.com/articles/2016/09/06/factory.html</a></li>
<li>工厂模式在tableviewCell中的使用：<a href="https://juejin.im/post/5b5c0fe3e51d451989055798" target="_blank" rel="external">https://juejin.im/post/5b5c0fe3e51d451989055798</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/建造者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/建造者模式/" itemprop="url">建造者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-18T16:56:59+08:00">
                2019-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h2><p>建造者模式通过一步步的提供输入来创建复杂的对象，而不需要在初始化的时候提供所有的输入。</p>
<p>这个模式包含以下三个方面：</p>
<p><img src="/2019/11/18/建造者模式/build_strategy.png" alt=""></p>
<ol>
<li>director接受输入并和builder配合。这通常是view controller或view controller使用的工具类。</li>
<li>product是将要被创建的复杂对象。根据所需的引用语义，它可以是结构体或类。它根据你的使用需要可以是任何类型，但通常是模型。</li>
<li>builder接收一步步的输入并负责product的创建。它通常是一个类。</li>
</ol>
<p>当你想要通过一系列的步骤来创建一个复杂对象时，你就可以考虑使用创造者模式。</p>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>使用这个模式来实现一个汉堡构造者</p>
<h3 id="1-定义product"><a href="#1-定义product" class="headerlink" title="1.定义product"></a>1.定义product</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// MARK: - Product</div><div class="line">public struct Hamburger &#123;</div><div class="line">  public let meat: Meat</div><div class="line">  public let sauce: Sauces</div><div class="line">  public let toppings: Toppings</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension Hamburger: CustomStringConvertible &#123;</div><div class="line">  public var description: String &#123;</div><div class="line">    return meat.rawValue + &quot; burger&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public enum Meat: String &#123;</div><div class="line">  case beef</div><div class="line">  case chicken</div><div class="line">  case kitten</div><div class="line">  case tofu</div><div class="line">&#125;</div><div class="line"></div><div class="line">public struct Sauces: OptionSet &#123;</div><div class="line">  public static let mayonnaise = Sauces(rawValue: 1 &lt;&lt; 0)</div><div class="line">  public static let mustard = Sauces(rawValue: 1 &lt;&lt; 1)</div><div class="line">  public static let ketchup = Sauces(rawValue: 1 &lt;&lt; 2)</div><div class="line">  public static let secret = Sauces(rawValue: 1 &lt;&lt; 3)</div><div class="line">  </div><div class="line">  public let rawValue: Int</div><div class="line">  public init(rawValue: Int) &#123;</div><div class="line">    self.rawValue = rawValue</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public struct Toppings: OptionSet &#123;</div><div class="line">  public static let cheese = Toppings(rawValue: 1 &lt;&lt; 0)</div><div class="line">  public static let lettuce = Toppings(rawValue: 1 &lt;&lt; 1)</div><div class="line">  public static let pickles = Toppings(rawValue: 1 &lt;&lt; 2)</div><div class="line">  public static let tomatoes = Toppings(rawValue: 1 &lt;&lt; 3)</div><div class="line">  </div><div class="line">  public let rawValue: Int</div><div class="line">  public init(rawValue: Int) &#123;</div><div class="line">    self.rawValue = rawValue</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-定义builder"><a href="#2-定义builder" class="headerlink" title="2.定义builder"></a>2.定义builder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// MARK: - Builder</div><div class="line">public class HamburgerBuilder &#123;</div><div class="line">  </div><div class="line">  public enum Error: Swift.Error &#123;</div><div class="line">    case soldOut</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public private(set) var meat: Meat = .beef</div><div class="line">  public private(set) var sauces: Sauces = []</div><div class="line">  public private(set) var toppings: Toppings = []</div><div class="line">  </div><div class="line">  private var soldOutMeats: [Meat] = [.kitten]</div><div class="line">  </div><div class="line">  public func addSauces(_ sauce: Sauces) &#123;</div><div class="line">    sauces.insert(sauce)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func removeSauces(_ sauce: Sauces) &#123;</div><div class="line">    sauces.remove(sauce)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func addToppings(_ topping: Toppings) &#123;</div><div class="line">    toppings.insert(topping)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func removeToppings(_ topping: Toppings) &#123;</div><div class="line">    toppings.remove(topping)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func setMeat(_ meat: Meat) throws &#123;</div><div class="line">    guard isAvailable(meat) else &#123; throw Error.soldOut &#125;</div><div class="line">    self.meat = meat</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func isAvailable(_ meat: Meat) -&gt; Bool &#123;</div><div class="line">    return !soldOutMeats.contains(meat)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func build() -&gt; Hamburger &#123;</div><div class="line">    return Hamburger(meat: meat,</div><div class="line">                     sauce: sauces,</div><div class="line">                     toppings: toppings)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-定义director"><a href="#3-定义director" class="headerlink" title="3.定义director"></a>3.定义director</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// MARK: - Director</div><div class="line">public class Employee &#123;</div><div class="line">  </div><div class="line">  public func createCombo1() throws -&gt; Hamburger &#123;</div><div class="line">    let builder = HamburgerBuilder()</div><div class="line">    try builder.setMeat(.beef)</div><div class="line">    builder.addSauces(.secret)</div><div class="line">    builder.addToppings([.lettuce, .tomatoes, .pickles])</div><div class="line">    return builder.build()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public func createKittenSpecial() throws -&gt; Hamburger &#123;</div><div class="line">    let builder = HamburgerBuilder()</div><div class="line">    try builder.setMeat(.kitten)</div><div class="line">    builder.addSauces(.mustard)</div><div class="line">    builder.addToppings([.lettuce, .tomatoes])</div><div class="line">    return builder.build()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-使用举例"><a href="#4-使用举例" class="headerlink" title="4.使用举例"></a>4.使用举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// MARK: - Example</div><div class="line">let burgerFlipper = Employee()</div><div class="line"></div><div class="line">if let combo1 = try? burgerFlipper.createCombo1() &#123;</div><div class="line">  print(&quot;Nom nom &quot; + combo1.description)</div><div class="line">&#125;</div><div class="line"></div><div class="line">if let kittenBurger = try?</div><div class="line">  burgerFlipper.createKittenSpecial() &#123;</div><div class="line">  print(&quot;Nom nom nom &quot; + kittenBurger.description)</div><div class="line">  </div><div class="line">&#125; else &#123;</div><div class="line">  print(&quot;Sorry, no kitten burgers here... :[&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>可以在一个表单页面使用创造者模式，当用户在表单输入的时候给builder输入，最后在点击完成的时候建造完成的product。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/15/策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/15/策略模式/" itemprop="url">策略模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T14:46:59+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h2><p>策略模式定义了一系列可互换的对象，这些对象在运行时可以互相更换。</p>
<p>策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。</p>
<p>再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。</p>
<p>策略模式定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>
<p>策略模式包含3部分:</p>
<p><img src="/2019/11/15/策略模式/strategy_overall.png" alt=""></p>
<ul>
<li>The object using a strategy：它经常是view controller，但在技术上也可以是任何需要可替换行为的对象。</li>
<li>strategy protocol：定义了每个策略都需要实现的方法</li>
<li>strategies：遵循strategy protocol协议的对象</li>
</ul>
<h2 id="使用例子：电影评分app"><a href="#使用例子：电影评分app" class="headerlink" title="使用例子：电影评分app"></a>使用例子：电影评分app</h2><p>这是一个使用多个电影评分服务的app，比如烂番茄，IMDb和Metacritic。我们可以使用策略模式为每个电影评分服务定义一些公共的api，而不是直接在view controller中为每个服务编写代码，并可能在代码里包含复杂的if-else语句。</p>
<h3 id="创建一个策略协议"><a href="#创建一个策略协议" class="headerlink" title="创建一个策略协议:"></a>创建一个策略协议:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public protocol MovieRatingStrategy &#123;</div><div class="line">    var ratingServiceName: String &#123; get &#125;</div><div class="line">    func fetchRating(for movieTitle: String,success: (_ rating: String, _ review: String) -&gt; ())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ratingServiceName表示服务的名字，比如返回“豆瓣”。</p>
<p>使用fetchRatingForMovieTitle(_:success:)来异步获取电影评分。</p>
<h3 id="实现多个服务"><a href="#实现多个服务" class="headerlink" title="实现多个服务"></a>实现多个服务</h3><p>首先实现烂番茄的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class RottenTomatoesClient: MovieRatingStrategy &#123;</div><div class="line">  public let ratingServiceName = &quot;Rotten Tomatoes&quot;</div><div class="line">  public func fetchRating(</div><div class="line">    for movieTitle: String,</div><div class="line">    success: (_ rating: String, _ review: String) -&gt; ()) &#123;</div><div class="line">    let rating = &quot;95%&quot;</div><div class="line">    let review = &quot;It rocked!&quot;</div><div class="line">    success(rating, review)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着实现IMBD服务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class IMDbClient: MovieRatingStrategy &#123;</div><div class="line">  public let ratingServiceName = &quot;IMDb&quot;</div><div class="line">  public func fetchRating(</div><div class="line">    for movieTitle: String,</div><div class="line">    success: (_ rating: String, _ review: String) -&gt; ()) &#123;</div><div class="line">    let rating = &quot;3 / 10&quot;</div><div class="line">    let review = &quot;&quot;&quot;</div><div class="line">      It was terrible! The audience was throwing rotten</div><div class="line">      tomatoes!</div><div class="line">      &quot;&quot;&quot;</div><div class="line">    success(rating, review)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MoviewRatingViewController: UIViewController &#123;</div><div class="line">  </div><div class="line">  // MARK: - Properties</div><div class="line">  public var movieRatingClient: MovieRatingStrategy!</div><div class="line">  </div><div class="line">  // MARK: - Outlets</div><div class="line">  @IBOutlet public var movieTitleTextField: UITextField!</div><div class="line">  @IBOutlet public var ratingServiceNameLabel: UILabel!</div><div class="line">  @IBOutlet public var ratingLabel: UILabel!</div><div class="line">  @IBOutlet public var reviewLabel: UILabel!</div><div class="line">  </div><div class="line">  // MARK: - View Lifecycle</div><div class="line">  public override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line">    ratingServiceNameLabel.text =</div><div class="line">      movieRatingClient.ratingServiceName</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // MARK: - Actions</div><div class="line">  @IBAction public func searchButtonPressed(sender: Any) &#123;</div><div class="line">    guard let movieTitle = movieTitleTextField.text</div><div class="line">      else &#123; return &#125;</div><div class="line">    </div><div class="line">    movieRatingClient.fetchRating(for: movieTitle) &#123;</div><div class="line">      (rating, review) in</div><div class="line">      self.ratingLabel.text = rating</div><div class="line">      self.reviewLabel.text = review</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>view controller不需要知道他在使用哪个策略，它只用依赖一个协议就够了。</p>
<p>view controller初始化的时候必定会传入一个策略，而它并不需要知道这个策略的具体实现。</p>
<h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>还有一个oc的使用例子：<a href="https://www.jianshu.com/p/014df9e21c35" target="_blank" rel="external">https://www.jianshu.com/p/014df9e21c35</a><br>还有一个验证textfield输入的例子：<a href="https://blog.csdn.net/wtdask/article/details/80454852" target="_blank" rel="external">https://blog.csdn.net/wtdask/article/details/80454852</a><br>如果代码理由有很多的if else的话，可以考虑用策略模式来优化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/15/Sourcetree设置SSH key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/15/Sourcetree设置SSH key/" itemprop="url">Sourcetree设置SSH key</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T10:57:59+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在使用Sourcetree的时候，遇到Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password)。</p>
<p>因为我本人有多个ssh密钥，但是Sourcetree貌似只会识别默认的密钥。</p>
<p>在每次重启电脑后在终端输入下面代码。</p>
<p><code>ssh-add ~/.ssh/&lt;username&gt;</code></p>
<p>Sourcetree就能够识别添加的密钥了，但是每次打开都要重新输入会很麻烦。</p>
<p>所以查阅资料后知道了如何让Sourcetree能读取所有的密钥。</p>
<p>1.进入ssh目录</p>
<p><code>cd ~/.ssh</code></p>
<p>2.打开config文件</p>
<p><code>vim config</code></p>
<p>3.修改config文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Host *</div><div class="line">    UseKeychain yes</div><div class="line">    AddKeysToAgent yes</div><div class="line">    IdentityFile ~/.ssh/id_rsa</div><div class="line">    IdentityFile ~/.ssh/github_rsa</div></pre></td></tr></table></figure>
<p>可以在这里输入多个密钥的目录。</p>
<blockquote>
<p>补充:</p>
<p>假如你拿到的是一台全新的机器, 那么你要按照下面的操作步骤进行:</p>
<ol>
<li><p>生成sshkey</p>
</li>
<li><p>执行ssh-add ~/.ssh/id_rsa 将ss hkey添加到sourceTree</p>
</li>
<li><p>执行ssh-add -K ~/.ssh/id_rsa 将sshkey添加到钥匙串。</p>
</li>
<li><p>cd 到 .ssh目录下, 用touch config命令创建config文件。</p>
</li>
<li><p>执行open config, 打开config文件。</p>
</li>
<li><p>输入上面的配置内容, 保存config文件。</p>
</li>
</ol>
</blockquote>
<p>以后每次启动电脑source tree都会自动加载sshkey.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/30/Instruments教程：入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/Instruments教程：入门/" itemprop="url">Instruments教程：入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T21:35:59+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>翻译自<a href="https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started" target="_blank" rel="external">Instruments Tutorial with Swift: Getting Started</a></p>
</blockquote>
<p>无论你是已经开发过很多app的老鸟，还是刚刚入门的菜鸟。你经常想的是如何实现新功能，或思考如何优化你的app。</p>
<p>但是除了添加新功能外，还有一件事情是所有优秀的开发者都需要做的，那就是调试代码！</p>
<p>本教程将向你展现如何使用Xcode自带的Instrments来帮你检查代码中存在的性能问题，内存问题，循环引用和其他问题。</p>
<p>在这个教程里，你将学习：</p>
<ol>
<li>如何使用<strong>Time Profiler</strong>仪器来定位代码中耗时长的地方，以使代码更有效率。</li>
<li>如何使用<strong>Allocations</strong>仪器来查找并修复代码中的内存问题，比如循环引用问题。</li>
</ol>
<blockquote>
<p><strong>注意</strong>:本教程假设你有一定的Swift和iOS编程经验。如果你刚开始接触iOS编程，那你可能需要先学习本网站的其他教程。本教程将会使用storyboards，所以请确保你了解相关知识。你可以在<a href="https://www.raywenderlich.com/81879/storyboards-tutorial-swift-part-1" target="_blank" rel="external">这个网站</a>学习相关知识。</p>
</blockquote>
<p>都准备好了吗？让我们准备好进入迷人的Instruments世界吧。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在此教程中你不需要从头创建好一个app。我们已经准备好一个示例项目了。您的任务是仔细检查这个app，并使用”Instruments”来优化它 - 非常类似于你优化自己app的过程！</p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/05/InstrumentsSwift-Starter.zip" target="_blank" rel="external">下载初始项目</a>,解压并打开项目。</p>
<p>这个示例app使用Flicker Api来搜索图片。为了使用API你需要一个API key。对于demo项目，你可以在Flicker的网站生成一个示例key。只需在<a href="http://www.flickr.com/services/api/explore/?method=flickr.photos.search" target="_blank" rel="external">http://www.flickr.com/services/api/explore/?method=flickr.photos.search</a>执行任意搜索并从URL中复制API密钥，它就在跟在”&amp;api_key=”后面。</p>
<p>举例来说，如果URL是：<br><strong><a href="http://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=6593783efea8e7f6dfc6b70bc03d2afb&amp;format=rest&amp;api_sig=f24f4e98063a9b8ecc8b522b238d5e2f" target="_blank" rel="external">http://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=6593783efea8e7f6dfc6b70bc03d2afb&amp;format=rest&amp;api_sig=f24f4e98063a9b8ecc8b522b238d5e2f</a></strong>,那么API key就是：6593783efea8e7f6dfc6b70bc03d2afb。</p>
<p>将它复制到<strong>FlickrSearcher.swift</strong>文件的最上面，将API key替换掉。</p>
<p>请注意，此示例API密钥每天都会更改，因此你偶尔需要重新生成一个新key。当key不再有效时，app将会提醒你。</p>
<p>编译运行app，执行一下搜索，点击结果，你会看到类似下面的情况：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/iOS-Simulator-Screen-Shot-21-Mar-2015-00.01.35.png" alt=""></p>
<p>浏览一下app并查看一下基本功能。你可能会觉得UI看起来不错，应该可以直接提交app store了。<br>但是，你接下来将看到instruments为你的app所带来的价值。</p>
<p>本教程的剩余内容将会像你展现如何查找并修复app中仍然存在的问题。你将看到<strong>Instruments</strong>如何使debug变得更加简单。</p>
<h2 id="分析时间"><a href="#分析时间" class="headerlink" title="分析时间"></a>分析时间</h2><p>第一个介绍的instrument是<strong>Time Profiler</strong>。以测量的间隔，Instruments将停止程序的执行，并对每个正在运行的线程采取堆栈跟踪。就将它想成在Xcode的调试器中按下暂停按钮。</p>
<p>这是<strong>Time Profiler</strong>的预览图：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.07.10-700x393.png" alt=""></p>
<p>这个屏幕展示了<strong>Call Tree</strong>。<strong>Call Tree</strong>显示了执行app中各种方法所花费的时间。每一行是程序执行时所调用的不同方法。在每个方法中花费的时间可以从每个方法中分析器停止的次数确定。</p>
<p>例如，如果以1毫秒的间隔完成100个样本，并且有个方法在堆栈中出现了10次，则可以推断出大约总执行时间的10％被花费在那个方法。这是一个相当粗略的近似值，但确实有效。</p>
<blockquote>
<p><strong>注意</strong>：一般来说，你应该始终在真实设备中测量应用，而不是在模拟器中。iOS模拟器具有Mac背后的所有马力，但真实设备却有移动硬件的限制。您的应用程序可能在模拟器中运行良好，但是一旦在真实设备上运行后，就会出现性能问题。</p>
</blockquote>
<p>所以还等什么，让我们马上拿到这个设备吧。</p>
<p>在Xcode的菜单栏，选择<strong>Product\Profile</strong>,或者按⌘I。这将会编译app并打开Instruments。你将会看到类似如下的选择窗口：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.12.32-700x394.png" alt=""></p>
<p>这里都是Instruments的不同模板。</p>
<p>选择<strong>Time Profiler</strong>仪器并点击<strong>Choose</strong>。这将会打开一个新的Instruments文件。点击左上方的红色记录按钮来开始记录并打开app。可能会要求你输入密码以授权仪器来分析其他流程 - 不要害怕，在这里提供密码是安全的！</p>
<p>在仪器窗口，您可以看到计时的时间，以及在屏幕中心的图形中从左向右移动的小箭头。这表示该应用正在运行。</p>
<p>现在，开始使用app。搜索一些图片，并了解更多一个或多个搜索结果。你可能注意到进入搜索结果非常慢。并且滑动搜索结果列表也是异常缓慢–这是一个非常笨拙的应用！</p>
<p>我们现在就要来修复它。不过你需要首先快速了解一下你在Instruments中看到的内容。</p>
<p>首先，确保工具栏右侧的视图选择器已选中两个选项，如下所示：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.14.53.png" alt=""></p>
<p>这将会确保全部的面板都是展开的，现在我们来研究一下下面的截图和每个分区的解释：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Pasted_Image_21_03_2015_00_17-700x497.png" alt=""></p>
<ol>
<li>这些是记录控制器。当这个红色记录按钮按下的时候，可以停止或启动正在被测量的app。这个停止按钮会终止正在运行的app。</li>
<li>这是运行计时器。计时器计算被测量的app已运行的时间，以及运行的次数。如果你停止，然后又重新启动app，就会开始一个新的运行，然后显示器将显示<strong>Run 2 of 2</strong>。</li>
<li>这叫做轨道。在<strong>Time Profiler</strong>模板中，只有一个仪器，所以这里只有一个轨道。你将在本教程稍后部分中详细了解该图形的具体细节。</li>
<li>这是细节面板。它显示了这个仪器的主要信息。在本例中，它显示了”最热”的方法–也就是那些占用了CPU最多时间的那些方法。如果你点击顶部的<strong>Call Tree</strong>（左边的那个）栏并选择<strong>Sample List</strong>，那它就会显示不同的数据视图。这个视图显示了每一个样本。点击一些样本，你就会在<strong>Extended Detail</strong>检查器看到捕捉到的调用栈。</li>
<li>这是检查面板。这里有3个检查器：Record Settings，Display Settings，和Extended Detail。你很快就会了解到有关这些选项的更多信息。</li>
</ol>
<p>现在来修复这笨拙的UI。</p>
<h2 id="更深入的研究"><a href="#更深入的研究" class="headerlink" title="更深入的研究"></a>更深入的研究</h2><p>执行图像搜索，并或取结果。我个人喜欢搜索”狗”，但你可以搜索任何你想搜索的。</p>
<p>现在，上下滑动几次列表，这样就能在<strong>Time Profiler</strong>里获取一定数量的数据。你应该注意到屏幕中间的数字在改变和图形在填充，这告诉你正在使用CPU周期。</p>
<p>你肯定不会希望任何UI像这样笨拙，为了查明这个问题，你需要设置一些选项。</p>
<p>在右边，选择<strong>Display Settings</strong>检查器（或者按⌘+2）。在检查器中，在<strong>Call Tree</strong>分区下，选中<strong>Separate by Thread</strong>, <strong>Invert Call Tree</strong>, <strong>Hide Missing Symbols</strong>和<strong>Hide System Libraries</strong>。看上去就像这样：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.22.21.png" alt=""></p>
<p>以下是每个选项对左侧表格中显示的数据的具体操作：</p>
<ul>
<li><strong>Separate by Thread</strong>：每个线程应该被分开考虑。这使你能够了解哪些线程负责最大量的CPU使用。</li>
<li><strong>Invert Call Tree</strong>：使用此选项，从上到下考虑堆栈跟踪。这通常是你想要的，因为你想要看到CPU花费时间的最深层次的方法。</li>
<li><strong>Hide Missing Symbols</strong>：如果您的应用程序或系统框架无法找到dSYM文件，那么你就不能在表中看到方法名称（符号），你将只能看到与二进制文件中的地址对应的十六进制值。如果选择此选项，则仅显示完全解析的符号，并且未解析的十六进制值被隐藏。这有助于减少所呈现的数据。</li>
<li><strong>Hide System Libraries</strong>：当这个选项选中的时候，只有你自己app里的符号会显示。选中这个选项非常有用，因为通常你只需要关心CPU在自己的代码中花费的时间。您不能对系统库使用多少CPU做很多事情！</li>
<li><strong>Flatten Recursion</strong>：此选项将递归函数（调用自身的函数）视为每个堆栈跟踪中的一个条目，而不是多个。</li>
<li><strong>Top Functions</strong>：启用此功能使得仪器将函数中花费的时间视为该函数内部时间的总和，以及由该函数调用的函数所花费的时间。因此，如果函数A调用B，那么A的时间会被记录为在A中花费的时间加上在B中花费的时间。这可以是非常有用的，因为它可以让您每次在调用堆栈时选择最大的时间数，调整你最耗时的方法。</li>
<li>如果你正在运行一个Objective-C程序，这里也有一个<strong>Show Obj-C Only</strong>选项：如果这个选中的话，那么仪器只会显示Objective-C方法，而不显示任何C或C++方法。这里没有这些方法，但是如果你正在查看一个OpenGL程序，那就可能会有一些C++代码。</li>
</ul>
<p>当你选中上面的选项后，尽管可能有一些数值会不一样，但整体的顺序应该跟下图很相似：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.24.07.png" alt=""></p>
<p>这看上去并不怎么好。绝大多数时间花在将”色调”滤镜应用到缩略图的方法中。你应该不会觉得太震惊，因为table view加载和滚动是这个UI的最卡的部分，也就是table cell在不断更新的时候。</p>
<p>要了解该方法中更多的信息，请双击表中的行。这样做就会出来下面的视图：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.25.39-700x377.png" alt=""></p>
<p>这很有趣，不是吗？<strong>applyTonalFilter()</strong>是一个<strong>UIImage</strong>扩展添加的方法，并且这里面将近100%的时间都是用在应用image filter后创建<strong>CGImage</strong>上面。</p>
<p>这里其实不能做什么优化来提升它的速度。因为创建图片是一个集中的过程，该花多少时间就会花多少时间。让我们试着回退来看看是哪里调用<strong>applyTonalFilter()</strong>的。点击<strong>Call Tree</strong>来回到之前屏幕：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.27.59-700x28.png" alt=""></p>
<p>现在点击<strong>applyTonalFilter</strong>行左边的小箭头。这会展开<strong>Call Tree</strong>来展现<strong>applyTonalFilter</strong>的调用者。你可能还需要展开更下一级。在分析Swift时，<strong>Call Tree</strong>中可能会有以<strong>@objc</strong>开头的重复的行。你应该只关注以你app名字（<strong>InstrumentsTutorial</strong>）命名的第一行：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.33.15-700x102.png" alt=""></p>
<p>在这个例子中，这一行指向了collectionView的<strong>cellForItemAtIndexPath</strong>方法。双击这一行来查看相关联的代码。</p>
<p>现在你可以看到问题的所在了。这个方法花了太多时间来执行滤镜方法了，并且是直接在<strong>cellForItemAtIndexPath</strong>中调用的，所以每次获得加滤镜的照片的时候都会堵塞主线程。</p>
<h2 id="卸载工作"><a href="#卸载工作" class="headerlink" title="卸载工作"></a>卸载工作</h2><p>你将进行两个步骤来解决这个问题：第一步，通过<strong>dispatch_async</strong>将滤镜效果移到子线程中，并且在每张图片创建之后缓存图片。初始项目里有一个很小，很简单的图片缓存类（名字为<strong>ImageCache</strong>），能将图片简单的存放在内存里并可以通过给定的key来进行检索。</p>
<p>你现在可以切换到Xcode并手动找到目标文件。但是在代码右上放有个很便利的<strong>在Xcode打开</strong>按钮。找到这个按钮并点击。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen_Shot_2015-03-21_at_00_36_58.png" alt=""></p>
<p>哈哈！Xcode直接打开这段代码了。</p>
<p>现在，在<strong>collectionView(_:cellForItemAtIndexPath:)</strong>，将调用<strong>loadThumbnail()</strong>的地方替换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">flickrPhoto.loadThumbnail &#123; image, error in</div><div class="line">  if cell.flickrPhoto == flickrPhoto &#123;</div><div class="line">    if flickrPhoto.isFavourite &#123;</div><div class="line">      cell.imageView.image = image</div><div class="line">    &#125; else &#123;</div><div class="line">      if let cachedImage = ImageCache.sharedCache.imageForKey(&quot;\(flickrPhoto.photoID)-filtered&quot;) &#123;</div><div class="line">        cell.imageView.image = cachedImage</div><div class="line">      &#125; else &#123;</div><div class="line">      	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), &#123;</div><div class="line">          if let filteredImage = image?.applyTonalFilter() &#123;</div><div class="line">            ImageCache.sharedCache.setImage(filteredImage, forKey: &quot;\(flickrPhoto.photoID)-filtered&quot;)</div><div class="line">            dispatch_async(dispatch_get_main_queue(), &#123;</div><div class="line">              cell.imageView.image = filteredImage</div><div class="line">            &#125;)</div><div class="line">	        &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的第一部分跟之前一样，从网络加载Flickr照片的缩略图。如果这张照片被设为喜欢了，cell展现这张缩略图，如果不是的话，就调用色调滤镜。</p>
<p>接下来就是代码有变化的地方了：首先，这段代码检查加了滤镜后的图片是否存在在缓存中，如果存在的话，直接将这张图片展现在imageView中。如果不是，在子线程中调用添加滤镜方法。这能使UI在图像添加滤镜时保持响应。当滤镜调用完之后，将这张图片添加到缓存中，最后在主线程中更新imageView。</p>
<p>这就是给图片添加滤镜所考虑的事情，但是在原始的调用方法上也有事情要考虑。打开<strong>FlickrSearcher.swift</strong>并找到<strong>loadThumbnail(_:)</strong>。替换成以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func loadThumbnail(completion: ImageLoadCompletion) &#123;</div><div class="line">  if let image = ImageCache.sharedCache.imageForKey(photoID) &#123;</div><div class="line">    completion(image: image, error: nil)</div><div class="line">  &#125; else &#123;</div><div class="line">    loadImageFromURL(URL: flickrImageURL(size: &quot;m&quot;)) &#123; image, error in</div><div class="line">      if let image = image &#123;</div><div class="line">        ImageCache.sharedCache.setImage(image, forKey: self.photoID)</div><div class="line">      &#125;</div><div class="line">      completion(image: image, error: error)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟添加滤镜的方法很相似。如果缓存中已经有图片了，那么直接调用完成闭包，返回存在的图片。否则，在Flickr加载图片并存储在缓存中。</p>
<p>通过在<strong>Product\Profile</strong>(或者⌘I)重新在Instruments中运行app。</p>
<p>请注意这次你讲不再被询问使用哪个instrument了。这是因为你仍然开着一个窗口，然后instruments假设你想用同样的选项再次运行。</p>
<p>执行几次搜索操作，然后你会发现这次UI不像之前那样卡顿。添加滤镜的操作现在是异步执行了并且缓存了图片，所以图片只需要被添加一次滤镜。你可以在<strong>Call Tree</strong>中看到一些<strong>dispatch_worker_threads</strong>，添加滤镜的繁重工作都交给它们来处理了。</p>
<h2 id="Allocations-Allocations-Allocations"><a href="#Allocations-Allocations-Allocations" class="headerlink" title="Allocations, Allocations, Allocations"></a>Allocations, Allocations, Allocations</h2><p>本教程下一个要介绍的instrument就是<strong>Allocations</strong>。它将为你提供正在创建的所有对象和它们内存的详细信息，它还显示每个对象的retain count。</p>
<p>要重新开始使用一个新的instrument profile，先退出instrument程序。这一次，编译并运行app，并在Navigators area中打开Debug Navigator。然后单击<strong>Memory</strong>，在主窗口中显示内存使用情况的图表：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.44.08-700x466.png" alt=""></p>
<p>这些图形可以帮助你快速了解app的性能表现。但是你需要更多的功能。点击<strong>Profile in Instruments</strong>按钮，然后点击<strong>Transfer</strong>将此会话传输到Instruments中。<strong>Allocations</strong> instrument会自动启动。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.47.56-700x460.png" alt=""></p>
<p>这次你会发现有两个轨道。一个叫做<strong>Allocations</strong>，另一个叫做<strong>Leaks</strong>。我们会在接下来的教程中讨论<strong>Allocation</strong>轨道。Leaks轨道通常在Objective-C中比较有用，本教程将不再讨论。</p>
<p>那么你接下来要跟踪的是什么bug呢？</p>
<p>这个项目中隐藏这一些你可能不知道的内容。你可能听说过内存泄漏。但是你可能不知道的是存在着两种泄漏：</p>
<ol>
<li><strong>True memory leaks</strong>是指一个对象不再被任何东西引用却依然被分配内存，也就是说这块内存永远不能被重用。即使Swift和ARC帮助管理内存，最常见的内存泄漏是<strong>ratain cycle</strong>或<strong>strong reference cycle</strong>。这是当两个对象互相强引用另一个对象时，使每个对象就会保证另一个对象不被释放。也就是说它们的内存空间永远不会被释放。</li>
<li><strong>Unbounded memory growth</strong>是指内存在持续增长并没有机会释放。如果这种情况一直持续，那么在某个时刻系统内存就会被填满。在iOS中意味着你的app会被系统杀死。</li>
</ol>
<p>在<strong>Allocations</strong> instrument运行app时，在app中做5次不同的搜索但不要深入了解结果。保证每次搜索都有一些结果。现在让app等待几秒钟。</p>
<p>你应该会注意到<strong>Alloactions</strong>轨道上的图形在增长。这是在告诉你正在分配内容。它是帮你找到<strong>unbounded memory growth</strong>的功能。</p>
<p>通得过点击<strong>Mark Generation</strong>来进行”generation analysis”。你能在<strong>Display Settings</strong>检查器的上方找到这个按钮：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.49.11.png" alt=""></p>
<p>点击它你会在轨道中看到一个红色的小旗子：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.49.51.png" alt=""></p>
<p>generation analysis的目的是多次执行一个动作，看看内存是否以无限制的方式发展。进行搜索，等待几秒钟来加载图片，然后返回主页面。然后再次点击mark generation。在不同的搜索上重复这些动作。</p>
<p>在执行几次搜索之后，Instruments看上去应该就像这样：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.53.19-700x403.png" alt=""></p>
<p>在这时，你应该会觉得疑惑。每次你搜索之后，蓝色的图形都会增加。这肯定是不太好的。但是什么是内存警告呢？内存警告是一种iOS告诉app内存使用越来越紧张，需要清除一些内存的方式。</p>
<p>这种增长可能不仅仅是由你的app造成的，它可能是UIKit的底层占据内存。给系统框架和你的app一个机会来清除他们内存。</p>
<p>通过选中Instrument菜单栏里的<strong>Instrument\Simulate Memory Warning</strong>或者模拟器菜单栏里的<strong>Hardware\Simulate Memory Warning</strong>来模拟内存警告。你会注意到内存使用量有所下降，或者根本就没有。当然不会回到它合理的地方。所以在某个地方仍然存在无限的内存增长。</p>
<p>在进行搜索的每次搜索之后标记的原因是你可以看到在每此标记之间分配了哪些内存。查看细节面板，你会看到一堆标记。</p>
<h2 id="谈谈我的标记"><a href="#谈谈我的标记" class="headerlink" title="谈谈我的标记"></a>谈谈我的标记</h2><p>在每次标记区间中，你会看到所有对象被分配并持续存在。后续的标记区间中依然存在上一个标记区间中存在的对象。</p>
<p>查看一下<strong>Growth</strong>列，你会看到确实在某处存在着增长。打开其中一个区间你看到这个：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.55.18-700x394.png" alt=""></p>
<p>哇！这里有好多对象。我们应该从哪里开始呢？</p>
<p>不幸的是，Swift的页面比Objective-C的页面更加杂乱，这里填满了很多你不需要知道的数据类型。你可一通关切换<strong>Allocation Type</strong>到<strong>All Heap Allocation</strong>来稍微清理一下。同时，点击<strong>Growth</strong>头来通过大小来排序。</p>
<p>靠近顶部的是<strong>ImageIO_jpeg_Data</strong>，这里肯定存在着一些你app的处理。点击<strong>ImageIO_jpeg_Data</strong>左边的箭头来显示完整的列表。选中一个并选择<strong>Extended Detail</strong>检查器（或按住⌘+3）。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-00.56.53-700x462.png" alt=""></p>
<p>这里显示了创建指定对象时的堆栈轨迹。灰色的堆栈轨迹是系统库的。黑色的才是你自己的代码。为了获得这个估计的上下文信息，双击倒数第几个帧，只有它是以”InstrumentsTutorial”为前缀的，表示他是来自Swift代码的。双击它就会带你来到你的老朋友–<strong>collectionView(_:cellForItemAtIndexPath:)</strong>方法中了。</p>
<p>Instrument非常有用，但在这个例子中它能帮到你更多。您现在将需要自己编写代码，来了解发生了什么。</p>
<p>看一下这个方法，你会看到它调用了<strong>setImage(_:forKey:)</strong>。当你看<strong>Time Profiler</strong>的时候，这个方法缓存了图片以防在app中再次用到这张图片。好吧，听起来好像有些问题。</p>
<p>再次点击<strong>Open in Xcode</strong>按钮来跳转到Xcode。打开<strong>ImageUtilities.swift</strong>并看一下<strong>setImage(_:forKey:)</strong>的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func setImage(image: UIImage, forKey key: String) &#123;</div><div class="line">  images[key] = image</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它将图片添加到一个以Flickr图片的图片ID作为key的字典中。但是如果你检查一下代码，你就会注意到字典中的图片从来没有清理过。</p>
<p>这就是你的无限增长内存的来源：一切正常工作，但app从来没有从缓存中删除任何东西 - 它只会添加它们。</p>
<p>为了修正这个问题，你所需要做的是让<strong>ImageCache</strong>监听<strong>UIApplication</strong>触发的内存警告通知。当<strong>ImageCache</strong>接收消息时，他必须清空它的内存。</p>
<p>为了让<strong>ImageCache</strong>监听这个通知，添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">  NSNotificationCenter.defaultCenter().addObserverForName(</div><div class="line">    UIApplicationDidReceiveMemoryWarningNotification,</div><div class="line">    object: nil, queue: NSOperationQueue.mainQueue()) &#123; notification in</div><div class="line">      self.images.removeAll(keepCapacity: false)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">deinit &#123;</div><div class="line">  NSNotificationCenter.defaultCenter().removeObserver(self,</div><div class="line">    name: UIApplicationDidReceiveMemoryWarningNotification,</div><div class="line">    object: nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里为<strong>UIApplicationDidReceiveMemoryWarningNotification</strong>注册了一个观察者来执行清除图片的闭包。</p>
<p>闭包里所做的事情就是清除缓存里的全部对象。这将确保images没有持有任何东西，他们都将被释放。</p>
<p>为了验证一下结果，再次打开instruments（在Xcode中按⌘I）并重复你之前的步骤。不要忘记在最后模拟内存警告。</p>
<blockquote>
<p><strong>注意</strong>:为了确保使用的是最新的代码，请确保在Xcode中打开，而不是只是按Instruments中的红色按钮。您可能还需要在分析之前进行编译和运行，因为如果你直接分析的话，有时Xcode似乎没有将模拟器中的app的版本更新为最新版本。</p>
</blockquote>
<p>这次生成的分析看上去应该像这样：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-01.06.38-700x466.png" alt=""></p>
<p>你会注意到在内存警告之后内存使用率下降。总体来说仍然有一些内存增长，但是与之前相比少了很多。</p>
<p>还在增长是系统库造成的，而且对此你也无能为力。这出现在系统库不能释放所有的内存的时候，这可能是设计的或是一个bug。你能做的就是释放尽可能多的内存。</p>
<p>太棒了！又有一个问题修复了！现在应该可以上架了吧！哦，等等，还有一种泄漏的问题你还没有解决。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>最终，你需要找到Flickr Search app中循环引用。就像之前提到的，当两个对象相互持有另一个对象的时候，就会出现循环引用，不能被释放，就会占用内存。你可以使用<strong>Allocations</strong> instrument来检测这种循环引用。</p>
<blockquote>
<p><strong>注意</strong>：要跟着本教程的这一章节继续走，你必须在真实设备上配置你的app。因为在写到这里时，如果在模拟器上运行<strong>Allocations</strong> instrument会出现一个bug，就是该项目中使用的大多数类不会显示在instrumets中。</p>
</blockquote>
<p>关闭Instruments，回到Xcode，确保在build target for the app中选的是你的设备。再次选择<strong>Product\Profile</strong>，并选择<strong>Allocations</strong>模板。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-01.08.52-700x394.png" alt=""></p>
<p>这一次，我们不再使用生成分析了。相应的，你将看到在内存中的不同类型的对象数。你应该已经看到细节面板中有大量的的对象了。</p>
<p>为了帮助我们缩小目标对象，在<strong>Allocations Summary</strong>中输入<strong>Instruments</strong>来过滤。这将只显示在其类型名称中具有单词”Instruments”的对象。因为这个app的名字是”InstrumentsTutorial”，这个<strong>Allocations</strong>列表将仅显示在此项目定义中的类型。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-01.10.35-700x149.png" alt=""></p>
<p>Instruments中值得注意的两列是<strong>Persistent</strong>和<strong>Transient</strong>。Persistent列中保留了内存中当前存在的每种类型的对象的数量。Transient列中显示了曾经存在但被释放的对象数量。Persistent对象正在使用内存，transient对象的内存已经释放掉了。</p>
<p>你应该看到一个<strong>ViewController</strong>的persistent实例，这是有道理的，因为这正是你在看的屏幕。这里还有<strong>AppDelegate</strong>，和一个Flickr API客户端的实例。</p>
<p>回到app中。执行一次搜索并进到结果中。注意到一些额外的对象已经出现在Instruments中：当解析搜索结果的时候创建了<strong>FlickrPhotos</strong>，<strong>SearchResultsViewController</strong>和<strong>ImageCache</strong>。<strong>ViewController</strong>依然存在，因为navigation controller需要它，这是ok的。</p>
<p>现在点击app中的返回按钮。<strong>SearchResultsViewController</strong>已经在导航堆栈中弹出了，所以它应该被释放。但是它依然在# Persistent中显示数量为1。为什么它还在呢？</p>
<p>试着执行另两次搜索并点击返回按钮。现在有3个<strong>SearchResultsViewController</strong>了。这些view controller依然能存在在内存中说明有东西对它们强引用了。看来代码中存在循环引用了。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-01.12.35-700x144.png" alt=""></p>
<p>在这种情况下，你的主要线索不仅是SearchResultsViewController持续存在，而且所有的<strong>SearchResultsCollectionViewCells</strong>也是如此。好像循环引用就是在这两个类之间产生的。</p>
<p>不幸的是，在写这篇文章的时候，Instruments的Swift输出在某些情况下不是很有用。Instruments只能给你关于问题在哪里的提示，并显示对象是在哪创建的。你的任务就是找出问题所在。</p>
<p>让我们深入代码，将你的鼠标放在<strong>Category</strong>列中的<strong>InstrumentsTutorial.SearchResultsCollectionViewCell</strong>上，并点击右边的小箭头。旁边的页面显示了在app运行期间所有<strong>SearchResultsCollectionViewCells</strong>的创建。每次产生搜索结果的时候都会有很多。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-03-21-at-01.14.55-700x283.png" alt=""></p>
<p>通过点击顶部栏第三个按钮来切换检查器到<strong>Extended Detail</strong>检查器。这个检查器显示了选中分配的堆栈追踪。跟之前的堆栈跟踪一样，黑色部分是您的代码。双击最上面的黑色行（以”InstrumentTutorial”开头），以查看cell分配的位置。</p>
<p>cell实在<strong>collectionView(cellForRowAtIndexPath:)</strong>最上面分配内存的。如果你浏览几行，你就会发现这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cell.heartToggleHandler = &#123; isStarred in</div><div class="line">  self.collectionView.reloadItemsAtIndexPaths([ indexPath ])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是处理在点击collection viiew cell上心形按钮时的闭包。这里就是出现循环引用的地方。除非你以前遇到过，否则很难发现。</p>
<p>cell使用<strong>self</strong>指向<strong>SearchResultsViewController</strong>，这创建了一个强应用。闭包捕捉了self。Swift实际上强制你明确地使用闭包中的self（而通常可以在引用当前对象的方法和属性时可以丢弃它）。这有助于你更加了解你捕获它的事实。<strong>SearchResultsViewController</strong>也通过他们的collection view对cell有强引用。</p>
<p>为了打破循环引用，你可以定义一个<strong>capture list</strong>作为闭包定义的一部分。capture list可以用来将被闭包捕获的实例声明为<strong>weak</strong>或<strong>unowned</strong>：</p>
<ul>
<li><strong>Weak</strong>应该在捕获引用可能未来会为nil的情况下使用。如果他们引用的对象被释放，则引用将变为nil。因此，它们是可选类型。</li>
<li><strong>Unowned</strong>应该在闭包和它的引用拥有相同的声明周期时，并且会同时释放时使用。一个unowned引用永远不可能为nil。</li>
</ul>
<p>为了修正循环引用，再次点击<strong>Open in Xcode</strong>并在<strong>SearchResultsViewController.swift</strong>的<strong>heartToggleHandler</strong>中加入capture list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cell.heartToggleHandler = &#123; [weak self] isStarred in</div><div class="line">  if let strongSelf = self &#123;</div><div class="line">    strongSelf.collectionView.reloadItemsAtIndexPaths([ indexPath ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明self为weak意味着即使collection view cell持有对<strong>SearchResultsViewController</strong>的引用，它也可以释放，因为它们现在只是弱引用。释放<strong>SearchResultsViewController</strong>将释放其collection view，接着就是cell了。</p>
<p>在Xcode内，再次使用<strong>⌘+I</strong>在Instruments中编译和运行app。</p>
<p>再次使用<strong>Allocations</strong>仪器查看app，就跟之前一样（请记住将结果过滤，仅显示本项目中的类）。执行搜索，导航到结果，然后返回。您应该看到当导航回来时，SearchResultsViewController及其cell现在都被释放。它们显示在transient实例中，而不是在persistent中。</p>
<p>循环被打破了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/19/CoreText教程：制作一个杂志app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/19/CoreText教程：制作一个杂志app/" itemprop="url">CoreText教程：制作一个杂志app</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-19T00:10:59+08:00">
                2017-07-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> 翻译自:<a href="https://www.raywenderlich.com/153591/core-text-tutorial-ios-making-magazine-app" target="_blank" rel="external">Core Text Tutorial for iOS: Making a Magazine App</a></p>
</blockquote>
<p><strong>Core Text</strong>是底层的文字处理引擎，当跟<strong>Core Graphics</strong>或<strong>Quartz</strong>一起使用时，可以对文本布局和格式进行细粒度的控制。</p>
<p>苹果在iOS7的时候发布了一个名为<a href="https://www.raywenderlich.com/77092/text-kit-tutorial-swift" target="_blank" rel="external">Text kit</a>的高级库，它能存储，布局并显示具有各种排版特性的文本。尽管Text Kit很强大，并且布局文本时足够用了，但是Core Text能提供更多控制。例如，如果你需要直接使用Quartz，那就使用Core Text。如果你需要构建你自己的布局引擎，Core Text能帮助你生成<a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533" target="_blank" rel="external">字形并使用优秀的排版功能来将它们相对彼此定位。</a></p>
<p>本教程将引导你使用Core Text来创建一个很简单的杂志程序…为僵尸写的。</p>
<p>对了，只要你忙着学习本教程，僵尸月刊的读者们就同意不吃掉你的大闹了。所以我们可能需要马上开始了。</p>
<blockquote>
<p><strong>注意：</strong>为了理解本教程，你需要了解iOS开发的基础知识。如果你刚开始接触iOS开发，那么我推荐你先看一下<a href="https://www.raywenderlich.com/category/ios" target="_blank" rel="external">其他教程</a>。</p>
</blockquote>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>打开Xcode，使用<strong>Single View Application模板</strong>创建新的<strong>Swift universal project</strong>，并命名为<strong>CoreTextMagazine</strong>。</p>
<p>接下来，添加Core Text framework到你的项目中：</p>
<ol>
<li>在项目导航栏里点击项目文件</li>
<li>在”General”栏下，向下滑到底部的”Linked Frameworks and Libraries”</li>
<li>点击”+”并搜索”CoreText”</li>
<li>选择”CoreText.framework”并点击”Add”按钮。</li>
</ol>
<p>现在项目已经建立完毕了，是时候开始编码了。</p>
<h2 id="添加一个Core-Text视图"><a href="#添加一个Core-Text视图" class="headerlink" title="添加一个Core Text视图"></a>添加一个Core Text视图</h2><p>首先，我们创建一个自定义的<strong>UIView</strong>，在它的<strong>draw(_:)</strong>方法里使用Core Text。</p>
<p>创建一个新的<strong>UIView</strong>的子类<strong>CTView</strong>。</p>
<p>打开<strong>CTView.swift</strong>,在<strong>import UIKit</strong>下添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import CoreText</div></pre></td></tr></table></figure>
<p>接下来，设置这个自定义视图为应用的主视图。打开<strong>Main.storyboard</strong>,打开右边栏的<strong>Utilities</strong>菜单，然后选择工具栏里的<strong>Identity Inspecrot</strong>图标。在<strong>Interface Builder</strong>左手边的菜单里，选中<strong>View</strong>。将<strong>Utilities</strong>菜单里的<strong>Class</strong>栏里填的<strong>UIView</strong>修改为<strong>CTView</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Screen-Shot-2017-06-07-at-12.43.13-PM.png" alt=""></p>
<p>接着，打开<strong>CTView.swift</strong>并将注释掉的draw(_:)替换为一下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//1	 	 </div><div class="line">override func draw(_ rect: CGRect) &#123;	 	 </div><div class="line">  // 2	 	 </div><div class="line">  guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;	 	 </div><div class="line">  // 3	 	 </div><div class="line">  let path = CGMutablePath()	 	 </div><div class="line">  path.addRect(bounds)	 	 </div><div class="line">  // 4</div><div class="line">  let attrString = NSAttributedString(string: &quot;Hello World&quot;)</div><div class="line">  // 5</div><div class="line">  let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class="line">  // 6</div><div class="line">  let frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, attrString.length), path, nil) </div><div class="line">  // 7</div><div class="line">  CTFrameDraw(frame, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们一步一步的看这段代码:</p>
<ol>
<li>再是图创建时，<strong>draw(_:)</strong>会自动运行来渲染视图的显示。</li>
<li>打开用来绘制的当前图像上下文。</li>
<li>创建一个限定绘制区域的路径，在本例中就是整个视图的边界。</li>
<li>在Core Text中，你使用<strong>NSAttributedStirng</strong>，而不是<strong>String</strong>或<strong>NSString</strong>来持有文本和文本属性。初始化内容为<strong>Hello World</strong>的attributed string。</li>
<li><strong>CTFramesetterCreateWithAttributedString</strong>通过所提供的attributed string来创建<strong>CTFramesetter</strong>。<strong>CTFramesetter</strong>将管理你的字体引用和你的绘制位置。</li>
<li>通过CTFramesetterCreateFrame在路径里渲染全部的字符串来创建<strong>CTFrame</strong>。</li>
<li><strong>CTFrameDraw</strong>在给定的上下文里绘制<strong>CTFrame</strong>。</li>
</ol>
<p>这就是画一个简单文本所需要做的事情。编译运行看下效果如何。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Screen-Shot-2017-06-07-at-12.47.10-PM-245x500.png" alt=""></p>
<p>…看上去好像不太对。就跟很多的底层API一样，Core Text使用Y轴翻转坐标系。更糟糕的是，内容也竖直翻转了。</p>
<p>在<strong>guard let context</strong>语句下加入以下代码来修复内容的方向问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Flip the coordinate system</div><div class="line">context.textMatrix = .identity</div><div class="line">context.translateBy(x: 0, y: bounds.size.height)</div><div class="line">context.scaleBy(x: 1.0, y: -1.0)</div></pre></td></tr></table></figure>
<p>该代码通过对视图的上下文使用转化来翻转内容。</p>
<p>编译运行app。不要担心状态栏的重叠问题。你将学习如何使用页面间距来解决这个问题。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Screen-Shot-2017-06-07-at-12.49.19-PM-245x500.png" alt=""></p>
<p>恭喜你构建了第一个Core Text app。僵尸们对你的进步很满意。</p>
<h2 id="Core-Text对象模型"><a href="#Core-Text对象模型" class="headerlink" title="Core Text对象模型"></a>Core Text对象模型</h2><p>也许你对<strong>CTFramesetter</strong>和<strong>CTFrame</strong>还有点疑惑，没关系，下面我来做下介绍。</p>
<p>Core Text对象模型看上去是这样的：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2011/06/CTClasses.jpg" alt=""></p>
<p>当你创建了一个<strong>CTFramesetter</strong>引用并给它提供一个<strong>NSAttributedString</strong>。一个<strong>CTTypesetter</strong>实例就自动创建来管理你的字体了。接下来就使用<strong>CTFramesetter</strong>来创建一个或多个你用来渲染文本的frame。</p>
<p>当你创建好文本，提供用来在它的矩形内渲染的文本范围。Core Text自动为每一行创建了<strong>CTLine</strong>，为每一个有相同格式的文本片段创建<strong>CTRun</strong>。比如说，Core Text会为一行中的几个红色的字创建<strong>CTRun</strong>，然后是纯文本的<strong>CTRun</strong>，然后又是粗体字的<strong>CTRun</strong>，等等。也就是说，Core Text基于<strong>NSAttributedString</strong>的属性来创建<strong>CTRun</strong>。此外，每一个<strong>CTRun</strong>对象可以采用不同的属性，所以你可以很好的控制字距，连字，宽度，高度等。</p>
<h2 id="回到杂志app"><a href="#回到杂志app" class="headerlink" title="回到杂志app"></a>回到杂志app</h2><p>下载并解压<img src="http://www.raywenderlich.com/downloads/zombieMagMaterials.zip" alt="僵尸杂志材料"></p>
<p>将文件夹拉到你Xcode项目中。出现提示时候，请确保勾选了<strong>Copy items if needed</strong>和<strong>Create groups</strong>。</p>
<p>为了完成这个app，你需要对文本应用各种属性。你将创建一个简单的文本标记解析器，它将使用标签来设置杂志app的格式。</p>
<p>创建一个新的Cocoa Touch类，命名为<strong>MarkupParser</strong>，设置为<strong>NSObject</strong>的子类。</p>
<p>首先，先看一下<strong>zombies.txt</strong>。看看整个文本是如何包含括号内的格式化标签？”img src”标签关联杂志的图片，”font color/face”标签确定文本颜色和字体。</p>
<p>打开<strong>MarkupParser.swift</strong>并将下面的代码写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import CoreText</div><div class="line"></div><div class="line">class MarkupParser: NSObject &#123;</div><div class="line">  </div><div class="line">  // MARK: - Properties</div><div class="line">  var color: UIColor = .black</div><div class="line">  var fontName: String = &quot;Arial&quot;</div><div class="line">  var attrString: NSMutableAttributedString!</div><div class="line">  var images: [[String: Any]] = []</div><div class="line"></div><div class="line">  // MARK: - Initializers</div><div class="line">  override init() &#123;</div><div class="line">    super.init()</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // MARK: - Internal</div><div class="line">  func parseMarkup(_ markup: String) &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们添加了一些属性来持有字体和文本颜色。设定他们的默认值。创建一个变量来持有<strong>parseMarkup(_:)</strong>生成的attributed  string。然后创建一个数组，它将最终保存定义文本中找到的图片大小，位置，文件名相关信息的字典。</p>
<p>写一个解析器通常是很难的，但是本教程的解析器将会非常简单并只支持开标签–也就是说一个标签将设置紧跟着它的文本的样式直到一个标签。文本标记看上去是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">These are &lt;font color=&quot;red&quot;&gt;red&lt;font color=&quot;black&quot;&gt; and</div><div class="line">&lt;font color=&quot;blue&quot;&gt;blue &lt;font color=&quot;black&quot;&gt;words.</div></pre></td></tr></table></figure>
<p>最终生成的输出就像这样：</p>
<p>These are <font color="red">red</font> and <font color="blue">blue</font> words.</p>
<p>在<strong>parseMarkup(_:)</strong>中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">attrString = NSMutableAttributedString(string: &quot;&quot;)</div><div class="line">//2 </div><div class="line">do &#123;</div><div class="line">  let regex = try NSRegularExpression(pattern: &quot;(.*?)(&lt;[^&gt;]+&gt;|\\Z)&quot;,</div><div class="line">                                      options: [.caseInsensitive,</div><div class="line">                                                .dotMatchesLineSeparators])</div><div class="line">  //3</div><div class="line">  let chunks = regex.matches(in: markup, </div><div class="line">                             options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">                             range: NSRange(location: 0,</div><div class="line">                                            length: markup.characters.count))</div><div class="line">&#125; catch _ &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>attrString</strong>刚开始是空的，但是最终将包含解析后的标记语言。</li>
<li>这个正则表达式，匹配马上跟着标签的文本块。它的意思是：查看字符串知道你找到一个开括号，然后接着看字符串直到你遇到了一个闭括号（或者是文档的结束部分）。</li>
<li>搜索正则表达式匹配的整个标记语言范围，然后生成一个<strong>NSTextCheckingResults</strong>数组。</li>
</ol>
<blockquote>
<p><strong>注意：</strong>更多关于正则表达式的内容可以在<a href="https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial" target="_blank" rel="external">NSRegularExpression Tutorial</a>看到。</p>
</blockquote>
<p>现在你已经解析了整个文本和格式标签到<strong>chunks</strong>中，你将循环<strong>chunks</strong>来构建attributed string。</p>
<p>但是在那之前，你有注意到<strong>matches(in:options:range:)</strong>是如何接收一个<strong>NSRange</strong>来作为一个参数的吗？在你的标记文本使用<strong>NSRegangeExpression</strong>函数时，将会有很多<strong>NSRange</strong>到<strong>Range</strong>的转换。swift是我们所有人的一个好朋友，所以我们需要帮一下它。</p>
<p>还是在<strong>MarkupParser.swift</strong>中，在文件的末尾添加下面的<strong>extension</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// MARK: - String</div><div class="line">extension String &#123;</div><div class="line">  func range(from range: NSRange) -&gt; Range&lt;String.Index&gt;? &#123;</div><div class="line">    guard let from16 = utf16.index(utf16.startIndex,</div><div class="line">                                   offsetBy: range.location,</div><div class="line">                                   limitedBy: utf16.endIndex),</div><div class="line">      let to16 = utf16.index(from16, offsetBy: range.length, limitedBy: utf16.endIndex),</div><div class="line">      let from = String.Index(from16, within: self),</div><div class="line">      let to = String.Index(to16, within: self) else &#123;</div><div class="line">        return nil</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    return from ..&lt; to</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数将String的起始和结束索引（以NSRange表示）转换为<strong>String.UTF16View.Index</strong>格式，即字符串UTF-16代码单元集合中的​​位置;然后转换每个<strong>String.UTF16View.Index</strong>到<strong>String.Index</strong>格式。当组合时，就会产生Swift的范围格式<strong>Range</strong>。只要索引时有效的，这个方法就会返回原始<strong>NSRange</strong>的<strong>Range</strong>表现。</p>
<p>现在是时候回头去处理文本和标签块了。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/zombie-thumbsup.png" alt=""></p>
<p>在<strong>parseMarkup(_:)</strong>中的<strong>let chunks</strong>(在<strong>do</strong>代码块里)下添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let defaultFont: UIFont = .systemFont(ofSize: UIScreen.main.bounds.size.height / 40)</div><div class="line">//1</div><div class="line">for chunk in chunks &#123;  </div><div class="line">  //2</div><div class="line">  guard let markupRange = markup.range(from: chunk.range) else &#123; continue &#125;</div><div class="line">  //3    </div><div class="line">  let parts = markup.substring(with: markupRange).components(separatedBy: &quot;&lt;&quot;)</div><div class="line">  //4</div><div class="line">  let font = UIFont(name: fontName, size: UIScreen.main.bounds.size.height / 40) ?? defaultFont       </div><div class="line">  //5</div><div class="line">  let attrs = [NSAttributedStringKey.foregroundColor: color, NSAttributedStringKey.font: font] as [NSAttributedStringKey : Any]</div><div class="line">  let text = NSMutableAttributedString(string: parts[0], attributes: attrs)</div><div class="line">  attrString.append(text)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>循环遍历<strong>chunks</strong>。</li>
<li>取得目前<strong>NSTextCheckingResult</strong>的范围，展开<strong>Range<string.index></string.index></strong>，只要它存在，就继续执行代码。</li>
<li>将<strong>chunk</strong>根据”&lt;”拆分成两部分。第一部分包含杂志文本，第二部分包含标签（如果有的话）。</li>
<li>使用<strong>fontName</strong>和跟屏幕大小相关的大小创建一个字体，字体名字目前默认是<strong>Arial</strong>，如果<strong>fontName</strong>不能产生一个有效的<strong>UIFont</strong>，设置<strong>font</strong>为默认的font。</li>
<li>创建字体格式的字典，将其应用于<strong>part[0]</strong>来创建attributed string，然后将该字符串添加到最终字符串里。</li>
</ol>
<p>为了处理”font”标签，在<strong>attrString.append(text)</strong>后面插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 1</div><div class="line">if parts.count &lt;= 1 &#123;</div><div class="line">  continue</div><div class="line">&#125;</div><div class="line">let tag = parts[1]</div><div class="line">//2</div><div class="line">if tag.hasPrefix(&quot;font&quot;) &#123;</div><div class="line">  let colorRegex = try NSRegularExpression(pattern: &quot;(?&lt;=color=\&quot;)\\w+&quot;, </div><div class="line">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class="line">  colorRegex.enumerateMatches(in: tag, </div><div class="line">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class="line">      //3</div><div class="line">      if let match = match,</div><div class="line">        let range = tag.range(from: match.range) &#123;</div><div class="line">          let colorSel = NSSelectorFromString(tag.substring(with:range) + &quot;Color&quot;)</div><div class="line">          color = UIColor.perform(colorSel).takeRetainedValue() as? UIColor ?? .black</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  //5    </div><div class="line">  let faceRegex = try NSRegularExpression(pattern: &quot;(?&lt;=face=\&quot;)[^\&quot;]+&quot;,</div><div class="line">                                          options: NSRegularExpression.Options(rawValue: 0))</div><div class="line">  faceRegex.enumerateMatches(in: tag, </div><div class="line">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class="line"></div><div class="line">      if let match = match,</div><div class="line">        let range = tag.range(from: match.range) &#123;</div><div class="line">          fontName = tag.substring(with: range)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125; //end of font parsing</div></pre></td></tr></table></figure>
<ol>
<li>如果小于两部分，跳过循环体的剩余部分。否则，将第二部分存储为<strong>tag</strong>。</li>
<li>如果<strong>tag</strong>以”font”开头，创建一个正则表达式来找到字体的”color”值，然后使用这个正则来遍历<strong>tag</strong>里匹配的”color”值。在这个例子中，这里应该只有一个匹配的颜色值。</li>
<li>如果<strong>enumerateMatches(in:options:range:using:)</strong>返回一个带着有效范围的<strong>match</strong>对象，找到这个指定的值（比如<strong>\<font color="red" \=""></font></strong>返回”red”）并将”Color”添加在后面来组成一个<strong>UIColor</strong>选择器。执行这个选择器，并将返回值设置到类中的<strong>color</strong>里。如果没有返回值无效的话就设置为黑色。</li>
<li>类似的，创建正则表达式来处理字体的”face”值。如果找到匹配的，设置<strong>fontName</strong>为该值。</li>
</ol>
<p>现在<strong>parseMarkup(_:)</strong>能解析标记语言并为Core Text生成<strong>NSAttributedString</strong>了。</p>
<p>我们让<strong>UIView</strong>来显示赋給它的文本。打开<strong>CTView.swift</strong>并在<strong>draw(_:):</strong>下添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// MARK: - Properties</div><div class="line">var attrString: NSAttributedString!</div><div class="line"></div><div class="line">// MARK: - Internal</div><div class="line">func importAttrString(_ attrString: NSAttributedString) &#123;</div><div class="line">  self.attrString = attrString</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，删除<strong>draw(_:)</strong>里的<strong>let attrString = NSAttributedString(string: “Hello World”)</strong>。</p>
<p>现在你创建了一个实例变量来持有attributed string和一个方法来给它赋值。</p>
<p>接着，打开<strong>ViewController.swift</strong>并添加如下代码到<strong>viewDidLoad():</strong>里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 1</div><div class="line">guard let file = Bundle.main.path(forResource: &quot;zombies&quot;, ofType: &quot;txt&quot;) else &#123; return &#125;</div><div class="line">  </div><div class="line">do &#123;</div><div class="line">  let text = try String(contentsOfFile: file, encoding: .utf8)</div><div class="line">  // 2</div><div class="line">  let parser = MarkupParser()</div><div class="line">  parser.parseMarkup(text)</div><div class="line">  (view as? CTView)?.importAttrString(parser.attrString)</div><div class="line">&#125; catch _ &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>将<strong>zombie.txt</strong>文件中的文本加载成<strong>string</strong>。</li>
<li>创建一个parser，输入文本，然后将解析出的attributed string传入<strong>viewController</strong>的<strong>CTView</strong>中。</li>
</ol>
<p>编译运行一下app！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Screen-Shot-2017-06-07-at-12.58.34-PM-245x500.png" alt=""></p>
<p>是不是很棒呢？多亏了50行的解析你能很方便的使用文本文件来持有杂志app的内容。</p>
<p>##杂志app的基本布局</p>
<p>如果你认为可怜的一页就能容下整个僵尸月刊的话，你就大错特错了。Core Text在布局多行的时候非常强大。因为<strong>CTFrameGetVisibleStringRange</strong>能告诉你一个给定的frame能放下多少文本。意思就是你可以先创建一列，当一列满了之后，你可以在创建另一列。</p>
<p>在这个app中，你需要先打印列，然后是页，然后是一整个杂志。所以是时候将你的<strong>CTView</strong>设置为是<strong>UIScrollView</strong>的子类了。</p>
<p>打开<strong>CTView.swift</strong>并修改<strong>class CTView</strong>行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class CTView: UIScrollView &#123;</div></pre></td></tr></table></figure>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/zombie-happy.png" alt=""></p>
<p>到目前为止，你已经在<strong>draw(_:)</strong>中创建了你的framesetter和frame，但是由于你将要有很多不同格式的很多行，所以最好还是创建单独的列实例。</p>
<p>创建一个新的Cocoa Touch Class文件命名为<strong>CTColumnView</strong>，<strong>UIView</strong>的子类。</p>
<p>打开<strong>CTColumnView.swift</strong>并添加如何代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import CoreText</div><div class="line"></div><div class="line">class CTColumnView: UIView &#123;</div><div class="line">  </div><div class="line">  // MARK: - Properties</div><div class="line">  var ctFrame: CTFrame!</div><div class="line">  </div><div class="line">  // MARK: - Initializers</div><div class="line">  required init(coder aDecoder: NSCoder) &#123;</div><div class="line">    super.init(coder: aDecoder)!</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  required init(frame: CGRect, ctframe: CTFrame) &#123;</div><div class="line">    super.init(frame: frame)</div><div class="line">    self.ctFrame = ctframe</div><div class="line">    backgroundColor = .white</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // MARK: - Life Cycle</div><div class="line">  override func draw(_ rect: CGRect) &#123;</div><div class="line">    guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;</div><div class="line">      </div><div class="line">    context.textMatrix = .identity</div><div class="line">    context.translateBy(x: 0, y: bounds.size.height)</div><div class="line">    context.scaleBy(x: 1.0, y: -1.0)</div><div class="line">      </div><div class="line">    CTFrameDraw(ctFrame, context)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这行代码就跟你最初在<strong>CTView</strong>中做的一样渲染了一个<strong>CTFrame</strong>。自定的初始化器<strong>init(frame:ctframe:)</strong>，设置了：</p>
<ol>
<li>此视图的frame。</li>
<li>用来在contenxt中绘制的<strong>CTFrame</strong>。</li>
<li>视图的背景颜色为白色。</li>
</ol>
<p>接着，创建一个新的swift文件命名为<strong>CTSettings.swift</strong>，用来持有你的列设定。替换<strong>CTSettings.swift</strong>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import Foundation</div><div class="line"></div><div class="line">class CTSettings &#123;</div><div class="line">  //1</div><div class="line">  // MARK: - Properties</div><div class="line">  let margin: CGFloat = 20</div><div class="line">  var columnsPerPage: CGFloat!</div><div class="line">  var pageRect: CGRect!</div><div class="line">  var columnRect: CGRect!</div><div class="line">  </div><div class="line">  // MARK: - Initializers</div><div class="line">  init() &#123;</div><div class="line">    //2</div><div class="line">    columnsPerPage = UIDevice.current.userInterfaceIdiom == .phone ? 1 : 2</div><div class="line">    //3</div><div class="line">    pageRect = UIScreen.main.bounds.insetBy(dx: margin, dy: margin)</div><div class="line">    //4</div><div class="line">    columnRect = CGRect(x: 0,</div><div class="line">                        y: 0,</div><div class="line">                        width: pageRect.width / columnsPerPage,</div><div class="line">                        height: pageRect.height).insetBy(dx: margin, dy: margin)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>这些属性决定每页的边距大小（本教程默认是20）；每页的行数；每一页的frame；和每一列的frame。</li>
<li>由于这本杂志要在iPhone和iPad上都能看，所以在iPad上展现两列，在iPhone上展现一列。这样不同的屏幕大小的列数都是合适的。</li>
<li>将整个页面的大小嵌入边距大小来计算pageRect。</li>
<li>将页面大小的宽度除以每行的列数得到新的frame并将这个frame嵌入边距得到<strong>columnRect</strong>。</li>
</ol>
<p>打开<strong>CTView.swift</strong>，将整个内容替换为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line">import CoreText</div><div class="line"></div><div class="line">class CTView: UIScrollView &#123;</div><div class="line"></div><div class="line">  //1</div><div class="line">  func buildFrames(withAttrString attrString: NSAttributedString,</div><div class="line">                   andImages images: [[String: Any]]) &#123;</div><div class="line">    //3</div><div class="line">    isPagingEnabled = true</div><div class="line">    //4</div><div class="line">    let framesetter = CTFramesetterCreateWithAttributedString(attrString as CFAttributedString)</div><div class="line">    //4</div><div class="line">    var pageView = UIView()</div><div class="line">    var textPos = 0</div><div class="line">    var columnIndex: CGFloat = 0</div><div class="line">    var pageIndex: CGFloat = 0</div><div class="line">    let settings = CTSettings()</div><div class="line">    //5</div><div class="line">    while textPos &lt; attrString.length &#123;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>buildFrames(withAttrString:andImages:)</strong>将创建<strong>CTColumnViews</strong>并将它们添加进scrollview。</li>
<li>启用scrollview的翻页功能。所以无论何时用户停止滚动，scrollview就会捕捉到，然后一整个页面就能显示出来。</li>
<li><strong>CTFramesetter framesetter</strong>将创建每一列的attributed text的<strong>CTFrame</strong>。</li>
<li><strong>UIView pageView</strong>将被当做是每一页当中列子视图的容器。<strong>textPos</strong>将会跟踪下一个字符。<strong>columnIndex</strong>将跟踪当前的列。<strong>pageIndex</strong>将跟踪当前页。<strong>setting</strong>能让你访问app的边距的大小，每页的列数，页面大小和列大小设定。</li>
<li>你将要遍历<strong>attString</strong>并一列一列的布局文本，直到当前的文本位置到最后了。</li>
</ol>
<p>下面我们就来遍历<strong>attrString</strong>。在<strong>while textPos &lt; attrString.length</strong>里添加下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">if columnIndex.truncatingRemainder(dividingBy: settings.columnsPerPage) == 0 &#123;</div><div class="line">  columnIndex = 0</div><div class="line">  pageView = UIView(frame: settings.pageRect.offsetBy(dx: pageIndex * bounds.width, dy: 0))</div><div class="line">  addSubview(pageView)</div><div class="line">  //2</div><div class="line">  pageIndex += 1</div><div class="line">&#125;   </div><div class="line">//3</div><div class="line">let columnXOrigin = pageView.frame.size.width / settings.columnsPerPage</div><div class="line">let columnOffset = columnIndex * columnXOrigin</div><div class="line">let columnFrame = settings.columnRect.offsetBy(dx: columnOffset, dy: 0)</div></pre></td></tr></table></figure>
<ol>
<li>如果列索引除以每页的列数取余等于0，那就表示该列是这一页的第一列，创建一个新的页视图来持有这些列。通过获取<strong>settings.pageRect</strong>并将它沿x轴方向偏移当前页乘以屏幕宽度的大小来计算新页的frame。这样在scrollview里，每一页都会在前一页的右边。</li>
<li>增加<strong>pageIndex</strong>。</li>
<li>通过将<strong>pageView</strong>的宽度除以<strong>settings.columnsPerPage</strong>来得到每列的宽度;将宽度乘以列索引以获得列偏移量;然后通过将标准<strong>columnRect</strong>并偏移<strong>columnOffset</strong>来创建当前列的frame。</li>
</ol>
<p>接下来，在<strong>columnFrame</strong>初始化器下添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//1   </div><div class="line">let path = CGMutablePath()</div><div class="line">path.addRect(CGRect(origin: .zero, size: columnFrame.size))</div><div class="line">let ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, nil)</div><div class="line">//2</div><div class="line">let column = CTColumnView(frame: columnFrame, ctframe: ctframe)</div><div class="line">pageView.addSubview(column)</div><div class="line">//3</div><div class="line">let frameRange = CTFrameGetVisibleStringRange(ctframe)</div><div class="line">textPos += frameRange.length</div><div class="line">//4</div><div class="line">columnIndex += 1</div></pre></td></tr></table></figure>
<ol>
<li>创建一个<strong>CGMutablePath</strong>获得列的大小，然后从<strong>textPos</strong>开始，用尽可能多的文本来渲染一个新的<strong>CTFrame</strong>。</li>
<li>使用<strong>CGRect columnFrame</strong>和<strong>CTFrame ctframe</strong>创建一个<strong>CTColumnView</strong>并添加该列到<strong>pageView</strong>。</li>
<li>使用<strong>CTFrameGetVisibleStringRange(_:)</strong>来计算该列包含文本的范围，然后将<strong>textPos</strong>增加范围的长度来反映当前的文本位置。</li>
<li>在下一次循环前列索引加1。</li>
</ol>
<p>最后在循环结束后设置scrollview的content size。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contentSize = CGSize(width: CGFloat(pageIndex) * bounds.size.width,</div><div class="line">                     height: bounds.size.height)</div></pre></td></tr></table></figure>
<p>通过将content size设置为屏幕宽度乘以页数，僵尸现在可以滑到到最后了。</p>
<p>打开<strong>ViewController.swift</strong>并替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(view as? CTView)?.importAttrString(parser.attrString)</div></pre></td></tr></table></figure>
<p>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(view as? CTView)?.buildFrames(withAttrString: parser.attrString, andImages: parser.images)</div></pre></td></tr></table></figure>
<p>在iPad上编译运行app，检查一下这两列的布局。在页面间左右滑动一下。看上去不错。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Screen-Shot-2017-06-08-at-12.41.06-PM.png" alt=""></p>
<p>你已经有了多列和格式化的文本，但是你还缺少图片。用Core Text并不能直接画图，毕竟这是一个文本框架。但是在您已经创建的解析器的帮助下，添加图像应该不会太难。</p>
<h2 id="使用Core-Text画图"><a href="#使用Core-Text画图" class="headerlink" title="使用Core Text画图"></a>使用Core Text画图</h2><p>尽管Core Text不能画图，作为一个布局引擎，它可以留下空白空间来为图片腾出空间。通过设置<strong>CTRun</strong>的代理，你可以决定<strong>CTRun</strong>的上升空间，降下空间和宽度，就像这样：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2011/06/CTRunDelegate.jpg" alt=""></p>
<p>当Core Text带着<strong>CTRunDelegate</strong>渲染到一个<strong>CTRun</strong>时,它会询问代理：我需要为这块数据留下多少空间。通过在<strong>CTRunDelegate</strong>设置这些属性，你可以在这些文本中为这些图片留下空间。</p>
<p>首先我们要支持解析<strong>img</strong>标签。打开<strong>MarkupParser.swift</strong>并在”} //end of font parsing”后面添加如何代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">else if tag.hasPrefix(&quot;img&quot;) &#123; </div><div class="line">      </div><div class="line">  var filename:String = &quot;&quot;</div><div class="line">  let imageRegex = try NSRegularExpression(pattern: &quot;(?&lt;=src=\&quot;)[^\&quot;]+&quot;,</div><div class="line">                                           options: NSRegularExpression.Options(rawValue: 0))</div><div class="line">  imageRegex.enumerateMatches(in: tag, </div><div class="line">    options: NSRegularExpression.MatchingOptions(rawValue: 0), </div><div class="line">    range: NSMakeRange(0, tag.characters.count)) &#123; (match, _, _) in</div><div class="line"></div><div class="line">    if let match = match,</div><div class="line">      let range = tag.range(from: match.range) &#123;</div><div class="line">        filename = tag.substring(with: range)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //2</div><div class="line">  let settings = CTSettings()</div><div class="line">  var width: CGFloat = settings.columnRect.width</div><div class="line">  var height: CGFloat = 0</div><div class="line"></div><div class="line">  if let image = UIImage(named: filename) &#123;</div><div class="line">    height = width * (image.size.height / image.size.width)</div><div class="line">    // 3</div><div class="line">    if height &gt; settings.columnRect.height - font.lineHeight &#123;</div><div class="line">      height = settings.columnRect.height - font.lineHeight</div><div class="line">      width = height * (image.size.width / image.size.height)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果<strong>tag</strong>以”img”开头，使用一个正则表达式来搜索图片的”src”值，也就是文件名。</li>
<li>设置图片的宽度为列的宽度并设置它的高度来使图片保持宽高比。</li>
<li>如果图片的高度比列的高度高，重新设置图片的高度来适应列的高度并减少宽度来保持图片的宽高比。由于图像后面的文本将包含空白属性，该包含空白属性的文本必须跟图片在同一列，所以设置图片高度为<strong>settings.columnRect.height - font.lineHeight.</strong>。</li>
</ol>
<p>接下来，在<strong>if let image</strong>块下添加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">images += [[&quot;width&quot;: NSNumber(value: Float(width)),</div><div class="line">            &quot;height&quot;: NSNumber(value: Float(height)),</div><div class="line">            &quot;filename&quot;: filename,</div><div class="line">            &quot;location&quot;: NSNumber(value: attrString.length)]]</div><div class="line">//2</div><div class="line">struct RunStruct &#123;</div><div class="line">  let ascent: CGFloat</div><div class="line">  let descent: CGFloat</div><div class="line">  let width: CGFloat</div><div class="line">&#125;</div><div class="line"></div><div class="line">let extentBuffer = UnsafeMutablePointer&lt;RunStruct&gt;.allocate(capacity: 1)</div><div class="line">extentBuffer.initialize(to: RunStruct(ascent: height, descent: 0, width: width))</div><div class="line">//3</div><div class="line">var callbacks = CTRunDelegateCallbacks(version: kCTRunDelegateVersion1, dealloc: &#123; (pointer) in</div><div class="line">&#125;, getAscent: &#123; (pointer) -&gt; CGFloat in</div><div class="line">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class="line">  return d.pointee.ascent</div><div class="line">&#125;, getDescent: &#123; (pointer) -&gt; CGFloat in</div><div class="line">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class="line">  return d.pointee.descent</div><div class="line">&#125;, getWidth: &#123; (pointer) -&gt; CGFloat in</div><div class="line">  let d = pointer.assumingMemoryBound(to: RunStruct.self)</div><div class="line">  return d.pointee.width</div><div class="line">&#125;)</div><div class="line">//4</div><div class="line">let delegate = CTRunDelegateCreate(&amp;callbacks, extentBuffer)</div><div class="line">//5</div><div class="line">let attrDictionaryDelegate = [(kCTRunDelegateAttributeName as NSAttributedStringKey): (delegate as Any)]              </div><div class="line">attrString.append(NSAttributedString(string: &quot; &quot;, attributes: attrDictionaryDelegate))</div></pre></td></tr></table></figure>
<ol>
<li>添加一个包含了图片大小，文件名，和文本位置的字典到<strong>images</strong>中。</li>
<li>定义<strong>RunStruct</strong>来持有一些属性，用来确定空白空间。然后初始化一个指针来包含一个<strong>ascent</strong>等于图片高度，<strong>width</strong>等于图片宽度的<strong>RunStruct</strong>。</li>
<li>创建一个<strong>CTRunDelegateCallbacks</strong>来返回返回属于<strong>RunStruct</strong>类型的指针的上升，下降和宽度属性。</li>
<li>使用<strong>CTRunDelegateCreate</strong>来创建一个将回调和数据参数绑定在一起的委托实例。</li>
<li>创建一个包含委托实例的属性字典，然后将一个空格追加到<strong>attrString</strong>，该空格持有空间的位置和大小信息。</li>
</ol>
<p>现在<strong>MarkupParser</strong>正在处理”img”标签，你需要修改<strong>CTColumnView</strong>和<strong>CTView</strong>来渲染它们。</p>
<p>打开<strong>CTColumnView.swift</strong>。在<strong>var ctFrame:CTFrame!</strong>下面添加代码来持有列的图片和位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var images: [(image: UIImage, frame: CGRect)] = []</div></pre></td></tr></table></figure>
<p>接下来，在<strong>draw(_:)</strong>下添加下面代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for imageData in images &#123;</div><div class="line">  if let image = imageData.image.cgImage &#123;</div><div class="line">    let imgBounds = imageData.frame</div><div class="line">    context.draw(image, in: imgBounds)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里你遍历每个图片并将它相应位置属性上画出来。</p>
<p>接下来打开<strong>CTView.swift</strong>并在类里添加下面属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// MARK: - Properties</div><div class="line">var imageIndex: Int!</div></pre></td></tr></table></figure>
<p><strong>imageIndex</strong>将跟踪你当前画在<strong>CTColumnViews</strong>中的图片索引。</p>
<p>接下来，在<strong>buildFrames(withAttrString:andImages:)</strong>添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imageIndex = 0</div></pre></td></tr></table></figure>
<p>这标记了<strong>images</strong>数组里的第一个元素。</p>
<p>接下来在<strong>buildFrames(withAttrString:andImages:)</strong>下面添加<strong>attachImagesWithFrame(_:ctframe:margin:columnView)</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func attachImagesWithFrame(_ images: [[String: Any]],</div><div class="line">                           ctframe: CTFrame,</div><div class="line">                           margin: CGFloat,</div><div class="line">                           columnView: CTColumnView) &#123;</div><div class="line">  //1</div><div class="line">  let lines = CTFrameGetLines(ctframe) as NSArray</div><div class="line">  //2</div><div class="line">  var origins = [CGPoint](repeating: .zero, count: lines.count)</div><div class="line">  CTFrameGetLineOrigins(ctframe, CFRangeMake(0, 0), &amp;origins)</div><div class="line">  //3</div><div class="line">  var nextImage = images[imageIndex]</div><div class="line">  guard var imgLocation = nextImage[&quot;location&quot;] as? Int else &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  //4</div><div class="line">  for lineIndex in 0..&lt;lines.count &#123;</div><div class="line">    let line = lines[lineIndex] as! CTLine</div><div class="line">    //5</div><div class="line">    if let glyphRuns = CTLineGetGlyphRuns(line) as? [CTRun], </div><div class="line">      let imageFilename = nextImage[&quot;filename&quot;] as? String, </div><div class="line">      let img = UIImage(named: imageFilename)  &#123; </div><div class="line">        for run in glyphRuns &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>获得<strong>ctframe</strong>的<strong>CTLine</strong>对象的数组。</li>
<li>使用<strong>CTFrameGetOrigins</strong>来将<strong>ctframe’s</strong>的行原点复制到<strong>origins</strong>数组中。设置范围的长度为0，<strong>CTFrameGetOrigins</strong>就会知道要遍历整个<strong>CTFrame</strong>。</li>
<li>设置<strong>nextImage</strong>来持有当前图片的图片属性。如果<strong>nextImage</strong>包含了图片的位置，解析它并继续循环，否则就提前退出。</li>
<li>遍历文本的行。</li>
<li>如果行的glyphRuns，图片名和图片名对应的图片全部存在，遍历这一行的glyphRun。</li>
</ol>
<p>接下来，在遍历gluphrun的代码里添加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 1</div><div class="line">let runRange = CTRunGetStringRange(run)    </div><div class="line">if runRange.location &gt; imgLocation || runRange.location + runRange.length &lt;= imgLocation &#123;</div><div class="line">  continue</div><div class="line">&#125;</div><div class="line">//2</div><div class="line">var imgBounds: CGRect = .zero</div><div class="line">var ascent: CGFloat = 0       </div><div class="line">imgBounds.size.width = CGFloat(CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, nil, nil))</div><div class="line">imgBounds.size.height = ascent</div><div class="line">//3</div><div class="line">let xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, nil)</div><div class="line">imgBounds.origin.x = origins[lineIndex].x + xOffset </div><div class="line">imgBounds.origin.y = origins[lineIndex].y</div><div class="line">//4</div><div class="line">columnView.images += [(image: img, frame: imgBounds)]</div><div class="line">//5</div><div class="line">imageIndex! += 1</div><div class="line">if imageIndex &lt; images.count &#123;</div><div class="line">  nextImage = images[imageIndex]</div><div class="line">  imgLocation = (nextImage[&quot;location&quot;] as AnyObject).intValue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果当前run的范围不包含下一张图片，跳过下面的循环。否则，在这里渲染图片。</li>
<li>使用<strong>CTRunGetTypographicBounds</strong>来计算图片的宽度，并设置高度为ascent。</li>
<li>使用CTLineGetOffsetForStringIndex获得行的x轴偏移量，并将其加上<strong>imgBounds</strong>的起点。</li>
<li>将该图片和图片的位置添加到当前的<strong>CTColumnView</strong>。</li>
<li>增加图片的索引。如果images[imageIndex]还存在图片的话，更新<strong>nextImage</strong>和<strong>imgLocation</strong>来指向下一张图片。</li>
</ol>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/04/runBounds.png" alt=""></p>
<p>好的，现在只差最后一步了。</p>
<p>在<strong>buildFrames（withAttrString：andImages :)</strong>里的<strong>pageView.addSubview（column）</strong>上面添加以下内容来添加图片（如果存在）：</p>
<p>在iPhone和iPad上都运行一下app吧！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/06/Screen-Shot-2017-06-08-at-12.51.19-PM.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/storyboard教程：下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/storyboard教程：下/" itemprop="url">storyboard教程：下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T23:06:59+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>翻译自:<a href="https://www.raywenderlich.com/113394/storyboards-tutorial-in-ios-9-part-2" target="_blank" rel="external">Storyboards Tutorial in iOS 9: Part 2</a></p>
</blockquote>
<p>如果你想了解更多关于storyboards的内容，那么你来对地方了！</p>
<p>在<a href="https://www.raywenderlich.com/?p=113388" target="_blank" rel="external">上部分的教程里</a>,你已经了解了如何使用Interface Builder来创建和连接view controllers，以及如何直接通过stoaryboad编辑器设计table view cells。</p>
<p>在下半部分的storyboard系列教程里，我们会覆盖segues，static table view cells,添加选手的页面和选择比赛的页面等内容。</p>
<p>我们将接着上部分的内容继续本教程，所以打开你之前创建的项目，或者在<a href="https://koenig-media.raywenderlich.com/uploads/2015/09/Storyboards-Part1.zip" target="_blank" rel="external">example code from the previous tutorial</a>下载。</p>
<p>好了，让我们继续学习storyboards中其他很酷的功能吧。</p>
<h2 id="介绍Segues"><a href="#介绍Segues" class="headerlink" title="介绍Segues"></a>介绍Segues</h2><p>是时候在storyboard中添加更多的view controller了。你将要先创建一个页面可以让用户增加选手。</p>
<p>打开<strong>Main.storyboard</strong>并拉取一个<strong>Bar Button Item</strong>到<strong>Player</strong>table view导航栏的右侧插槽中。在<strong>Attributes inspector</strong>里设置<strong>Identifier</strong>为<strong>Add</strong>来使他变成一个标准+按钮。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/PlayersAddButton.png" alt=""></p>
<p>当用户点击这个按钮时，会弹出一个可以输入新选手的详细信息的新页面。</p>
<p>在页面中拉取一个新的<strong>Table View Controller</strong>，放在Palyers场景的右边。记住你可以双击页面来缩小页面，这样你就有更多的空间方便拉取。选择这个新的Table View Controller，依次选择<strong>Editor\Embed in\Navigation Controller</strong>。</p>
<p>这里有个小诀窍：选中刚才添加进Player场景的+按钮，然后按住ctrl的同时拖动鼠标到新的Navigation Controller上，松开鼠标，在弹出的小菜单中选择<strong>present modally</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/PresentModally2.gif" alt=""></p>
<blockquote>
<p><strong>提醒</strong>：你不能在页面缩放的时候在stroayboard中添加或修改内容。如果你在创建segue的时候碰到了问题，试着双击恢复页面尺寸吧。</p>
</blockquote>
<p>在Payers场景和Navigation Controller中间出现一个新的箭头：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/09/03_sb2_modalrelation.png" alt=""></p>
<p>你之前所看到的storyboard中的连接都表示的是一个view controller包含了另一个。而上图这种类型的连接称为<strong>segue</strong>，它表示了一个场景到另一个场景的跳转。也就是说segue改变了当前场景上的页面。按钮的点击，table view cells，手势等等都可以触发一个segue。</p>
<p>使用segue的好处是你不需要再写代码来实现页面的跳转了，也不需要捕捉按钮的<strong>IBAction</strong>方法。你刚才做的，直接用鼠标从bar Button连接到下一个场景就创建了这种跳转。（注意：如果你的控件已经有了一个<strong>IBAction</strong>连接，segue会覆盖它。）</p>
<p>运行app并点击+按钮。一个新的tableview会滑上来。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppPresentModally1.gif" alt=""></p>
<p>这被称为”modal”segue。这个新的场景完全遮住了之前的场景。用户不能跟底下的场景交互，除非先把这个modal场景关了。后面你还将看到在导航控制器的导航栈上push新场景的”show”segue。</p>
<p>这个新的场景现在没什么功能，你甚至不能关闭它然后回到原来的主场景。这是因为segue只能单向走，所以它只能从Player场景到新的场景，却不能往回走。</p>
<p>Storyboard可以通过unwind segue功能来实现返回。下面实现unwind segue的三个步骤：</p>
<ol>
<li>创建一个对象供用户选择，一般都是一个按钮。</li>
<li>在你要返回的controller中创建一个unwind方法。</li>
<li>在storyboard中关联这个方法和对象。</li>
</ol>
<p>首先，打开<strong>Main.storyboard</strong>,选中这个新的Table View Controller场景。双击导航栏，改变场景的标题为<strong>Add Player</strong>。然后添加两个<strong>Bar Button Items</strong>，分别放在导航栏的两边。在<strong>Attributes inspector</strong>中，设置左边按钮的<strong>System Item</strong>属性为<strong>Cancel</strong>，右边的设置为<strong>Done</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AddPlayerButtons-468x500.png" alt=""></p>
<p>接下来，使用<strong>Cocoa Touch Class</strong>模板在项目中创建新的文件，命名为<strong>PlayeDetailsViewController</strong>，选择为<strong>UITableViewController</strong>的子类。为了将这个类跟storyboard关联起来，回到<strong>Main.storyboard</strong>选择Add Player场景。在<strong>Identity inspectro</strong>中设置它了<strong>Class</strong>属性为<strong>PlayerDetailsViewController</strong>。我总是忘记这非常重要的一步，所以请确保你别忘了。我还会继续指出这一点的。</p>
<p>现在你终于能实现unwind segue了。在<strong>PlayersViewController.swift</strong>（不是detail cotroller）中，增加unwind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@IBAction func cancelToPlayersViewController(segue:UIStoryboardSegue) &#123;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">@IBAction func savePlayerDetail(segue:UIStoryboardSegue) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>cancelToPlayersViewController(_:)</strong>是为unwind segue实现的简单标记。等下你会在<strong>savePlayerDetail(_:)</strong>中增加代码来获取它的名字。</p>
<p>最后，切换回<strong>Main.storyboard</strong>然后关联Cancel和Done按钮到它们各自的方法上。按住ctrl的拖动bar button到view controller上方的exit对象上然后在弹出菜单中选择正确的方法名字:</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/09/06_sb2_connectdone2.gif" alt=""></p>
<p>注意你取消方法的名字。当你创建一个unwind segue，这个列表会展示整个app中所有的unwind方法（也就是<strong>@IBAction func methodname(segue:UIStoryboardSegue)</strong>样式的方法），所以一定要确保创建你能识别的名字。</p>
<p>运行app，点击+按钮，然后测试Cancel和Done按钮。我们只用一点代码就实现了很多功能。</p>
<h2 id="Static-Cells"><a href="#Static-Cells" class="headerlink" title="Static Cells"></a>Static Cells</h2><p>当你完成这一章节内容的时候，Add Player场景看上去会是下面这个样子：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppAddPlayer1.png" alt=""></p>
<p>这是一个分组的table view，但是你还没为这个表格创建数据源。对于这个table view来说，你可以直接在storyboard中设计，不需要在<strong>cellForRowAtIndexPath(_:)</strong>写代码。使这件事成为可能的功能称为<strong>static cells</strong>。</p>
<p>在Add Palyer场景中选中table view，在<strong>Attributes inspector</strong>中设置<strong>Content</strong>属性为<strong>Static Cells</strong>。将<strong>Style</strong>属性从Plain设置为<strong>Grouped</strong>，<strong>Sections</strong>设为2。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/StaticCells1.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：当你改变Sections属性时，编辑器会复制当前存在的section。（你也可以在Document Outline选中指定的section来复制它。）</p>
</blockquote>
<p>完成后的场景应该在每个section中只有1行，所以删除每个section中多余的两个cell。</p>
<p>选中最上面的Table View Section（在Document Outline）中。在它的<strong>Attributes inspecrot</strong>中，在<strong>Header</strong>栏里设置值为<strong>Player Name</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/09/PlayerName1.png" alt=""></p>
<p>在这个cell中拉取一个新的Text Field。拉伸它的宽度，移除它的边框，这样你就看不到他的开始位置和结束位置。设置Font为<strong>System 17.0</strong>并去掉<strong>Adjust to Fit</strong>前面的勾。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/09/FormatPlayerName.png" alt=""></p>
<p>你将使用Xcode中的Assistant Editor功能在<strong>PlayerDetailsViewController</strong>中为这个text field创建一个outlet。仍然在storyboard中，通过点击toolbar中的按钮来打开<strong>Assistant Editor</strong>（右上角显示两个连着的环的按钮）。它应该自动打开<strong>PlayerDetailsViewController.swift</strong>（如果没有，请使用右边拆分窗口中的跳转条来选择.swift文件）。</p>
<p>选中新的text field然后按住ctrl键拖动它到.swift文件中的上方位置，就在class定义的下面。当弹框出现，命名这个新的outlet为<strong>nameTextField</strong>，点击Connect。点击Connect之后，Xcode会在PlayersDetailViewController类中增加这个连接至storyboard的属性：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/09/NameTextField.gif" alt=""></p>
<p>为table cells上的视图创建outles正是那种我说过的不应该用在prototype cell上的东西，但是在tatic cell中可以使用。每个static cell只会有一个实例，所以将它的子视图连接到view controller上的outlet是可以接受的。</p>
<p>将第二个section的static cell的<strong>Style</strong>设置为<strong>Right Detail</strong>。这样你就在一个标准样式的cell上操作了。双击label，修改字符为<strong>Game</strong>，设置cell的accessory为<strong>Disclosure Indicator</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/PlayerGame.png" alt=""></p>
<p>就跟你在Name文本框中的操作一样，在右边的文件中为这个新的label创建一个outlet，命名为<strong>detailLabel</strong>。这个label就是普通的<strong>UILabel</strong>对象。在将label拖到<strong>PlayerDetailsViewController.swift</strong>前你可能需要多点几次”Detail”来选中这个label（不是选中整个cell）。完成之后，看上去应该像这样：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/DetailLabel.png" alt=""></p>
<p>Add Player场景最终看上去应该像这样：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AddPlayer.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：你至今在storyboard中创建的场景都有iPhone6的4.7英寸屏幕的宽度和高度，也就是677像素的高度。很显然，你的app应该在所有不同大小屏幕的设备上都能使用，你可以在storyboard中预览所有大小的屏幕。<br>打开工具条中的<strong>Assistant Editor</strong>，使用跳转栏来选择<strong>Preview</strong>。在assistant的左下角点击<strong>+</strong>符号来添加一个新的屏幕尺寸来预览。可以通过点击Delete键来删除一个屏幕尺寸。<br><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/Preview.png" alt=""><br>对于这个app，你不需要做任何花哨的事情。它只使用table view controller并且会自动调整大小来适应屏幕空间。当你需要在不同大小的设备上支持不同的布局时，你将会使用Auto Layout和Size Classes。</p>
</blockquote>
<p>编译运行app，你会看到Add Player场景仍然是空白的！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppAddPlayerBlank-281x500.png" alt=""></p>
<p>当你使用static cell时，你的table view controller中不需要写数据源代码。因为你使用使用Xcode模板来创建<strong>PlayerDetailViewController</strong>类，类中仍然会有一些数据源的占位代码，这将阻碍static cell正常工作。这也是内容空白的原因。是时候来修复它了。</p>
<p>打开<strong>PlayerDetailsViewController.swift</strong>删除这一行下面的所有东西（除了类定义的闭括号）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// MARK: - Table view data source</div></pre></td></tr></table></figure>
<p>运行app检查下这个带有static cell的场景。没有写一行代码，实际上，你扔掉了大量的代码。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppAddPlayer-281x500.png" alt=""></p>
<p>还有一件关于static cell的事：它只能在UITableViewController上使用。尽管Interface Builder会让你在普通的<strong>UIViewController</strong>中的Table View对象中加入它们，但是在运行时不会有效果。原因是<strong>UITableViewController</strong>提供了额外的操作来处理static cell的数据源。Xcode甚至会阻止在编译这样一个项目时会报错：”Illegal Configuration: Static table views are only valid when embedded in UITableViewController instances”。另一方面，prototype cell在普通view controller中的table view里能正常运行。</p>
<blockquote>
<p><strong>注意</strong>：如果你创建一个带有很多static cell的场景，超过了可见尺寸的大小。那么你可以使用鼠标或触控板上的滚动手势（2根手指滑动）在Interface Builder中滚动浏览它们。这可能不是很明显，但确实是有效的。</p>
</blockquote>
<p>即使是使用static cell，你也不能总是避免编写代码。当你在第一个cell中拉取了一个text field，你可能注意到它并不是完全适配。text field距离两边有很小的空白空间。用户看不到text field的开头和结尾，所以如果用户点击在页面的空白上然后键盘没有出现，他们会很疑惑。</p>
<p>为了避免这发生，你应该使在这一行的任何点击都能唤起键盘。这很简单就能实现，只需要打开<strong>PlayerDetailsViewControlelr.swift</strong>并加入<strong>tableView(_:didSelectRowAtIndexPath:)</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123;</div><div class="line">  if indexPath.section == 0 &#123;</div><div class="line">    nameTextField.becomeFirstResponder()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的意思是如果用户点击了第一个cell，这个app应该唤起text field。在这个section中只有一个cell所以你只需要检验section索引。使text field变成第一响应者会自带唤起键盘。这只是一点调整，却能解决用户可能的困扰。</p>
<blockquote>
<p><strong>提示</strong>：当你加入代理方法，或者覆盖view controller的方法时，只需要输入方法名字（不需要前缀”func”），然后你就能在可用列表中选择你想要的方法了。</p>
</blockquote>
<p>你也应该设置cell的Selection Style为<strong>None</strong>（而不是Default），否则当用户点击空白处时这一整行会高亮。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/SelectionNone.png" alt=""></p>
<p>好了，Add Player场景的显示设计就完成了。现在来实现它的功能吧。</p>
<h2 id="使Add-Player场景工作"><a href="#使Add-Player场景工作" class="headerlink" title="使Add Player场景工作"></a>使Add Player场景工作</h2><p>现在你将忽略Game行，只要让用户能输入运动员的名字就行了。</p>
<p>当用户点击Cancel按钮时，这个场景应该关闭，所有输入的数据都会被丢掉。这一部分早就通过unwind segue完成了。</p>
<p>当用户点击Done按钮时，你应该创建一个新的Player对象给它的属性赋值，最后更新我们的运动员列表。</p>
<p>当一个segue发生时将会调用<strong>prepareForSegue(_:sender:)</strong>。你将覆盖这个方法来使页面消失前来存储输入的数据。</p>
<blockquote>
<p><strong>注意</strong>：你永远不能自己调用<strong>prepareForSegue(_:sender:)</strong>。这个UIKit用来让你知道segue将要被触发的消息。</p>
</blockquote>
<p>在<strong>PlayerDetailsViewController.swift</strong>中，首先在类的上面加入一个属性来持有你将要添加的player数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var player:Player?</div></pre></td></tr></table></figure>
<p>接着添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123;</div><div class="line">  if segue.identifier == &quot;SavePlayerDetail&quot; &#123;</div><div class="line">    player = Player(name: nameTextField.text!, game: &quot;Chess&quot;, rating: 1)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>prepareForSegue(_:sender:)</strong>方法里创建了game和rating都为默认值的<strong>Palyer</strong>对象。它只会在带有<strong>SavePlayerDetail</strong>标识的segue下运行。</p>
<p>在<strong>Main.storyboard</strong>中，在Document Outline中找到Add Player场景并选择绑定<strong>savePlayerDetail</strong>动作的unwind segue。改变<strong>Identifier</strong>为<strong>SavePlayerDetail</strong>：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/SavePlayerDetail.png" alt=""></p>
<p>到<strong>PlayerViewController</strong>中修改unwind segue方法<strong>savePlayerDetail(segue:)</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@IBAction func savePlayerDetail(segue:UIStoryboardSegue) &#123;</div><div class="line">  if let playerDetailsViewController = segue.sourceViewController as? PlayerDetailsViewController &#123;</div><div class="line">      </div><div class="line">    //add the new player to the players array</div><div class="line">    if let player = playerDetailsViewController.player &#123;</div><div class="line">      players.append(player)</div><div class="line">      </div><div class="line">      //update the tableView</div><div class="line">      let indexPath = NSIndexPath(forRow: players.count-1, inSection: 0)</div><div class="line">      tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这通过传递给该方法的segue引用获得对<strong>PlayerDetailsViewController</strong>的引用。它使用这个引用来添加新<strong>Player</strong>对象到数据源players列表中。然后它告诉table view添加了一个新行（在底部），因为table view和它的数据源必须保持同步。</p>
<p>你可以直接使用<strong>tableView.reloadData()</strong>来完成但是一个带动画的插入看上去更好一点。<strong>UITableViewRowAnimation.Automatic</strong>自动选择适当的动画，具体取决于你插入的新行的位置。很方便。</p>
<p>试一下吧，你现在应该能添加新player对象到列表中了！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppWithNewPlayers.png" alt=""></p>
<p>##性能</p>
<p>现在你已经在storyboard中有了一些view controller了，你可能想知道性能如何。一次加载一整个storyboard不是一件大事。Storyboard不会马上初始化所有的view controller，只有初始view controller是马上加载的。因为你的初始view controller是一个Tab Bar Controller，所以它包含的两个view controller也被加载了。</p>
<p>其他的view controller不会实例化直到你跳转到它们。当你关闭这些view controller时它们会马上释放，所以内存中只有正在使用的view controller。</p>
<p>让我们在实际例子中看看吧。在<strong>PlayerDetailsViewController</strong>中加入初始化器和析构器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">required init?(coder aDecoder: NSCoder) &#123;</div><div class="line">  print(&quot;init PlayerDetailsViewController&quot;)</div><div class="line">  super.init(coder: aDecoder)</div><div class="line">&#125;</div><div class="line">  </div><div class="line">deinit &#123;</div><div class="line">  print(&quot;deinit PlayerDetailsViewController&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你覆写了<strong>init?(coder:)</strong>和<strong>deinit</strong>，并让它们在Xcode调试窗口打印信息。现在再次运行app并打开Add Player场景。你应该看到这个view controller直到使用到时才被分配。</p>
<p>当你关闭Add Player场景，不论是点击Cancel还是Done，你应该看到<strong>print()</strong>的释放日志信息。如果你再次打开这个场景，你应该也能再看到<strong>init?(coder:)</strong>中的信息。这应该能确保view controller能按需加载。</p>
<h2 id="比赛选择场景"><a href="#比赛选择场景" class="headerlink" title="比赛选择场景"></a>比赛选择场景</h2><p>点击Add Player场景中的Game行应该打开一个新的场景，可以让用户在一个列表中选择比赛。这意味着你将添加另一个table view controller，尽管这时你应该将它push到导航栈中而不是用之前的modal展示它。</p>
<p>拉取一个新的<strong>Table View Controllr</strong>到<strong>Main.storyboard</strong>中。在Add Player场景中选择Game table view cell（确保选择的是整个cell，而不是其中的一个label），按住ctrl键，拖动到新的Table View Controller来创建它们之间的segue。设置它为<strong>Show</strong>segue（在弹出框<strong>Selection Segue</strong>分组下的，不是Accessory下的）。</p>
<p>选择这个新的segue并在它的Attributes Inspector中设置标识为<strong>PickGame</strong>。</p>
<p>在<strong>Document Outline</strong>中选择这个新的Table View Controller，命名这个场景为<strong>Choose Game</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/ChooseGame.png" alt=""></p>
<p>设置prototype的<strong>Style</strong>为<strong>Basic</strong>，并设置reuse identifier为<strong>GameCell</strong>。这就是场景需要做的设计了：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/GameCell.png" alt=""></p>
<p>在这个新的项目中加入新的Swift文件，使用<strong>Cocoa Touch Class</strong>模板并命名它为<strong>GamePickerViewController</strong>，是<strong>UITableViewController</strong>。</p>
<p>回到<strong>Main.storyboard</strong>中的<strong>Choose Game</strong>场景，并在Identity Inspector设置它的Custom Class为<strong>GamePickerViewController</strong>。</p>
<p>现在让我们给这个新的场景一些数据来显示吧。在<strong>GamePickerViewController.swift</strong>，加入一个名为<strong>games</strong>的填充了一些固定值的数组属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var games:[String] = [</div><div class="line">    &quot;Angry Birds&quot;,</div><div class="line">    &quot;Chess&quot;,</div><div class="line">    &quot;Russian Roulette&quot;,</div><div class="line">    &quot;Spin the Bottle&quot;,</div><div class="line">    &quot;Texas Hold&apos;em Poker&quot;,</div><div class="line">    &quot;Tic-Tac-Toe&quot;]</div></pre></td></tr></table></figure>
<p>现在再模板中替换数据源方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;</div><div class="line">  return 1</div><div class="line">&#125;</div><div class="line">  </div><div class="line">override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class="line">  return games.count</div><div class="line">&#125;</div><div class="line">  </div><div class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class="line">  let cell = tableView.dequeueReusableCellWithIdentifier(&quot;GameCell&quot;, forIndexPath: indexPath) </div><div class="line">  cell.textLabel?.text = games[indexPath.row]</div><div class="line">  return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你只是设置数据源为<strong>games</strong>数组并替换cell的textLabel中的值。</p>
<p>就数据源而言应该这样做。运行app并点击Game行。选择比赛的新场景将会滑入到当前视图。现在点击新场景里的cell不会做任何事情，但是因为这个场景是在导航栈中呈现的，你总是可以点击返回按钮回到Add Player场景。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppChooseGame.png" alt=""></p>
<p>这很酷。你不需要写任何代码来调用这个新场景。你只是按住ctrl，从static table view cell拖动到新的场景而已。唯一你写代码的地方是填充tableView的内容，这通常是更动态的而不是写死的列表。</p>
<p>当然，如果新场景没有传递任何数据回来，它就没什么用处，所以你还是为它需要添加一个新的unwind segue。</p>
<p>在<strong>GamePickerViewController</strong>类里，添加属性来持有当前选择比赛的名字和索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var selectedGame:String? &#123;</div><div class="line">  didSet &#123;</div><div class="line">    if let game = selectedGame &#123;</div><div class="line">      selectedGameIndex = games.indexOf(game)!</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var selectedGameIndex:Int?</div></pre></td></tr></table></figure>
<p>每当<strong>selectedGame</strong>被更新的时候，<strong>didSet</strong>将依据正确的索引在<strong>games</strong>中找到game字符串并更新<strong>selectedGameIndex</strong>。</p>
<p>接下来，改变<strong>tableView(_:cellForRowAtIndexPath:)</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class="line">  let cell = tableView.dequeueReusableCellWithIdentifier(&quot;GameCell&quot;, forIndexPath: indexPath)</div><div class="line">  cell.textLabel?.text = games[indexPath.row]</div><div class="line">  </div><div class="line">  if indexPath.row == selectedGameIndex &#123;</div><div class="line">    cell.accessoryType = .Checkmark</div><div class="line">  &#125; else &#123;</div><div class="line">    cell.accessoryType = .None</div><div class="line">  &#125;</div><div class="line">  return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将在包含当前选中game的cell设置复选标记。这样的小动作会得到用户的赞赏。</p>
<p>现在添加代理方法<strong>tableview(_:didSelectRowAtIndexPath:)</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123;</div><div class="line">  tableView.deselectRowAtIndexPath(indexPath, animated: true)</div><div class="line">    </div><div class="line">  //Other row is selected - need to deselect it</div><div class="line">  if let index = selectedGameIndex &#123;</div><div class="line">    let cell = tableView.cellForRowAtIndexPath(NSIndexPath(forRow: index, inSection: 0))</div><div class="line">    cell?.accessoryType = .None</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  selectedGame = games[indexPath.row]</div><div class="line"></div><div class="line">  //update the checkmark for the current row</div><div class="line">  let cell = tableView.cellForRowAtIndexPath(indexPath)</div><div class="line">  cell?.accessoryType = .Checkmark</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用户点击cell时，Table View代理会调用这个方法。</p>
<p>首先这个方法在用户点击cell之后取消选择状态。这使得它从灰色高亮颜色回到常规的白色。然后它移除之前选中cell的复选标记，将它放在刚刚点击的行上。</p>
<p>运行app来测试一下。点击比赛的名字然后相应的行会得到一个复选标记。点击另一个比赛的名字这样复选标记也会随之改变。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppGameCheckmark.png" alt=""></p>
<p>这个场景应该在你点击一行后就关闭，然后现在并没有发生。因为你没有绑定unwind segue。这就是我们下一步应该做的。</p>
<p>在<strong>PlayerDetailsViewController.swift</strong>中，添加一个属性来持有选中的比赛，这样你等下就能在Player对象中保存它。给它一个默认值”Chess”，这样新的player总会有一个比赛属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var game:String = &quot;Chess&quot; &#123;</div><div class="line">  didSet &#123;</div><div class="line">    detailLabel.text? = game</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>didSet</strong>会在比赛名字改变时在static cell中显示比赛的名字。</p>
<p>还是在<strong>PlayerDetailsViewController.swift</strong>中，加入unwind segue方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@IBAction func unwindWithSelectedGame(segue:UIStoryboardSegue) &#123;</div><div class="line">  if let gamePickerViewController = segue.sourceViewController as? GamePickerViewController,</div><div class="line">    selectedGame = gamePickerViewController.selectedGame &#123;</div><div class="line">      game = selectedGame</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦用户在Choose Game场景选中比赛上面的代码就会执行。这个方法同时更新屏幕上的label和game属性。unwind segue也会在导航控制栈中推出GamePickerViewController。</p>
<p>在<strong>Main.storyboard</strong>，跟之前一样，按住ctrl拉取cell到<strong>Exit</strong>，然后在弹出列表中选择<strong>unwindWithSelectedGame</strong>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/09/UnwindWithSelectedGame.gif" alt=""></p>
<p>在<strong>Attributes Inspector</strong>中设置unwind segue的Identifier为<strong>SaveSelectedGame</strong>。</p>
<p>运行app，创建一个新的player，选择player的比赛行来选择一个比赛。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/09/19_sb2_selectedGame.jpg" alt=""></p>
<p>Add Player场景的比赛并没有更新！</p>
<p>unwind segue方法在<strong>tableView(_:didSelectRowAtIndexPath:)</strong>之前执行了，所以<strong>SelectedGameIndex</strong>没有及时更新。你可以覆写<strong>prepareForSegue(_:sender:)</strong>，在unwind发生前更新数据。</p>
<p>在<strong>GamePickerViewController</strong>，覆写<strong>prepareForSegue(_:sender:)</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123;</div><div class="line">  if segue.identifier == &quot;SaveSelectedGame&quot; &#123;</div><div class="line">    if let cell = sender as? UITableViewCell &#123;</div><div class="line">      let indexPath = tableView.indexPathForCell(cell)</div><div class="line">      if let index = indexPath?.row &#123;</div><div class="line">        selectedGame = games[index]</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>prepareForSegue(_:sender:)</strong>的参数sender就是初始化这个segue的对象，在这个例子中就是你选中的比赛cell。所以你可以使用cell的indexPath来找到<strong>games</strong>数组中的对应的game来设置<strong>selectedGame</strong>，这样你就能在unwind segue中获得这个参数了。</p>
<p>现在当你运行app，并选中比赛时，它会更新palyer的比赛信息！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppItWorks.png" alt=""></p>
<p>接下来，你需要修改PlayerDetailsViewController中的<strong>prepareForSegue(_:sender:)</strong>来返回选中的比赛，而不是默认写死的”Chess”。这样，当你成功添加新player对象的时候，Players场景就会展现真实的比赛。</p>
<p>在<strong>PlayerDetailsViewController.swift</strong>，修改<strong>prepareForSegue(_:sender:)</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123;</div><div class="line">  if segue.identifier == &quot;SavePlayerDetail&quot; &#123;</div><div class="line">    player = Player(name: nameTextField.text, game:game, rating: 1)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你完成添加新选手，点击Done，players列表会更新成正确的比赛。</p>
<p>还有一件事，当你选择一个比赛，回到Add Player场景，然后试着再选择比赛，你之前选的比赛前面应该有个复选框。实现手的方案是传递PlayerDetailsViewController里存储的选中比赛到GamePickerViewContr中。</p>
<p>还是在<strong>PlayerDetailsViewController.swift</strong>中，在<strong>prepareForSegue(_:sender:)</strong>在结尾处添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if segue.identifier == &quot;PickGame&quot; &#123;</div><div class="line">  if let gamePickerViewController = segue.destinationViewController as? GamePickerViewController &#123;</div><div class="line">    gamePickerViewController.selectedGame = game</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你有两个<strong>if</strong>语句来检查<strong>segue.identifier</strong>。<strong>SavePlayerDetail</strong>是回到选手列表的unwind segue，<strong>PickGame</strong>是前往Game Pick场景的展示segue。你添加的代码能够在视图加载前设置GamePickerViewController的<strong>selectedGame</strong>。设置<strong>selectedGame</strong>会自动更新<strong>selectedGameIndex</strong>，table view就是用这个属性来设置复选框的。</p>
<p>太棒了！你现在有一个添加比赛的场景了。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/08/AppFinalGameScene.png" alt=""></p>
<p>您可以在<a href="https://koenig-media.raywenderlich.com/uploads/2015/09/Storyboards-Part2.zip" target="_blank" rel="external">Ratings iOS 9 example project</a>里下载本教程所有的代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/storyboard教程：上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="蒋正义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒋正义的修炼之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/storyboard教程：上/" itemprop="url">storyboard教程：上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T22:49:59+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> 翻译自:<a href="https://www.raywenderlich.com/113388/storyboards-tutorial-in-ios-9-part-1" target="_blank" rel="external">Storyboards Tutorial in iOS 9: Part 1</a></p>
</blockquote>
<p>Storyboards 是在iOS5的时候出现的一个新功能，它帮助我们在构建界面时节省了很多的时间。<br>我用一张图来展示什么是Storyboards，这就是你将要在这个教程里构建的Storyboards。</p>
<p><img src="/2017/06/27/storyboard教程：上/BeginningStoryboard.png" alt=""></p>
<p>你可能不清楚这个app是做什么的，但你可以很清楚的看到app的各个screen和他们之间的连接关系。<br>Storyboards有以下几个优点：</p>
<ul>
<li>你可以在视觉上很直观的布局你view controllers中的各个场景并且表现他们之间的连接。通过stroryboard你会对你app中的各个场景有更好的概念。</li>
<li>Stroyboards还可以表现场景间的跳转。这个跳转被称为”segues”,你可以通过在stroryboard中连接view controllers来创建”sugeus”。通过它你就可以在UI上少写点代码啦。</li>
<li>在Storyboards中使用table view会简单很多。有了tableview 的prototype cells和static cells功能，你基本上就可以在stroryboard的编辑栏里来设计你的tableview了，减少了很多你原来不得不写的代码。</li>
<li>Storyboards在使用Auto Layout上也简单很多。Auto Layout定义了你页面中各个UI的位置和大小，有了这个强大的功能，你在适配不同大小的屏幕时就简单多了。在这个教 程中，你只会使用用一点点Auto Layout，但是在这个教程外，你可以通过<a href="https://www.raywenderlich.com/?p=%2083129" target="_blank" rel="external">Auto Layout Tutorial</a>或者<a href="http://www.raywenderlich.com/video-tutorials#autolayout" target="_blank" rel="external">watch the video series</a>来了解更多的内容。</li>
</ul>
<p>在本教程中你将要创建一个简单的app，这个app可以添加有关选手，比赛和他们技能水平的列表。在这项任务中，你会学到一些在stroryboards中常用的功能。</p>
<h2 id="项目入门"><a href="#项目入门" class="headerlink" title="项目入门"></a>项目入门</h2><p>打开Xcode创建一个新项目，选择Single View Application模板。</p>
<p><img src="/2017/06/27/storyboard教程：上/XcodeProject.png" alt=""></p>
<p>按照以下方式填写：</p>
<ul>
<li>Product Name: <strong>Ratings</strong></li>
<li>Organization Name: 随便填啥</li>
<li>Organization Identifier: 你apps使用的identifier</li>
<li>Language: <strong>Swift</strong></li>
<li>Devices: <strong>iPhone</strong></li>
<li>Use Core Data: 不勾选</li>
<li>Include Unit Tests and UI Tests: 不勾选</li>
<li>创建好项目之后，Xcode的主要界面应该看上去是这样的：</li>
</ul>
<p><img src="/2017/06/27/storyboard教程：上/MainWindow.png" alt=""></p>
<p>这个新的项目包含了两个类，<strong>AppDelegate</strong>和<strong>ViewController</strong>以及本教程的重点<strong>Main.storyboard</strong>。<br>这个app只支持竖立显示，所以去掉上图显示的<strong>Landscape Left</strong>和<strong>Landscape Right</strong>前面的勾。<br>然后让我们来看一下storyboard吧。点击导航栏中的Main.storyboard。</p>
<p><img src="/2017/06/27/storyboard教程：上/MainStoryboard.png" alt=""></p>
<p>view controller在stroryboard中的官方术语叫做’scene‘，但是你可以互换这些术语，在stroryboard中secne表现的就是view controller。<br>在上图中你看到了一个view controller包含了一个空白页面。左边的箭头表示这个view controller是这个stroryboard的初始view controller。<br>通过拖拽对象库里的控件（在右下角）到你的view controller中来设置页面。是不是很简单？</p>
<blockquote>
<p><strong>注意</strong>：你会发现默认的scene是方的。Xcode7默认开启了Auto Layout和Size Classes。这两个功能可以使你构建一个灵活的界面，并且很方便的调整大小。这对你适配不同大小的屏幕很有帮助。你可以在<a href="https://videos.raywenderlich.com/#adaptivelayout" target="_blank" rel="external">Adaptive Layout video tutorial series</a>了解更多有关size classes的内容。</p>
</blockquote>
<p>在本教程中，你可以重新调整屏幕大小，方便你更直观的看到最终的界面是什么样子的。在继续下面的内容之前，重新调整scene的大小来模拟iPhone6/6s。</p>
<p>在Document Outline中选中<strong>View Controller</strong>。如果你没看到的Document Outline的话，点击storyboard面板中左下角的这个按钮。</p>
<p><img src="/2017/06/27/storyboard教程：上/DocumentOutlineIcon.png" alt=""></p>
<p>在<strong>Simulated Metrics</strong>下的<strong>Attributes Insepector</strong>改变<strong>Size</strong>为<strong>iPhone 4.7 inch</strong>。</p>
<p><img src="/2017/06/27/storyboard教程：上/SimulatedMetrics-446x320.png" alt=""></p>
<p>现在storyboard中的场景的大小就是iPhone6或者6s的大小了，也就是4.7英寸iphone的大小。<br>”Inferred“是<strong>Simulated Metrics</strong>的默认设置。<strong>Simulated Metircs</strong>是stroryboard内置的视觉设计辅助来展示屏幕的样子。请记住他们在运行的时候不会被使用。<br>拉取一些对象库里的控件到view controller来感受一下storyboard到底是怎么工作的吧。</p>
<p><img src="/2017/06/27/storyboard教程：上/DragControls.gif" alt=""></p>
<p>当你拖进这个控件后，这个控件应该会显示在左边的Document Outline里：</p>
<p><img src="/2017/06/27/storyboard教程：上/DocumentOutline.png" alt=""></p>
<p>storyboard显示你的view controllers里面所有的内容。目前这里只有一个view controller（也可称scene）在你的storyboard中，但在本教程的学习过程中你将会添加几个其他的view controller。<br>在scene的上方有个微型的Document Outline，这被称为Dock：</p>
<p><img src="/2017/06/27/storyboard教程：上/TheDock.png" alt=""></p>
<p>Dock显示scene中的顶级对象。每个scene至少有一个<strong>View Controller</strong>对象，一个<strong>First Responder</strong>对象，和一个<strong>Exit</strong>选项，当然它也可以有其他顶级对象。Dock可以很方便的连接<strong>outlets</strong>和<strong>actions</strong>。如果你要连接一些东西到这个view controller，只需要简单的将它拉取到Dock的图标上。</p>
<blockquote>
<p>注意：你可能不是很常使用到<strong>First Responder</strong>。这是一个代理对象，指任何对象在任何给定时间都有第一个第一响应状态。举一个例子，你可以截取按钮对象的按下动作来调用First Responder的复制方法。如果一个文本框在响应状态了那么你就可以按下按钮来使First Responder（也就是文本框）复制文字。</p>
</blockquote>
<p>运行这个app，它看上去应该跟你在stroyboard里设计的一样：</p>
<p><img src="/2017/06/27/storyboard教程：上/SimulatorTesting.png" alt=""></p>
<p>这是你定义的初始View Controller，但是这个app到底是怎么加载的呢？仔细看看application delegate来找到答案吧。打开<strong>AppDelegate.swift</strong>来看看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">@UIApplicationMain</div><div class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</div><div class="line"></div><div class="line">	var window: UIWindow?</div><div class="line"></div><div class="line">	func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;</div><div class="line">    // Override point for customization after application launch.</div><div class="line">    return true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件顶部的<strong>@UIApplicationMain</strong>属性指定AppDelegate类是模块的入口。使用storyboard的要求是appdelegate继承自<strong>UIResponder</strong>并且有<strong>UIWindow</strong>属性。所有的方法几乎都是空白的，就连<strong>application(_:didFinishLaunchingWithOptions:)</strong>也只是简单地返回了true。<br>秘密藏在info.plist文件里。点击项目导航栏里的<strong>Info.plist</strong>你会看到：</p>
<p><img src="/2017/06/27/storyboard教程：上/InfoPlist.png" alt=""></p>
<p>使用Storyboard的app用<strong>UIMainStoryboardFile</strong>这个key，也可以称为”Main storyboard file base name“,来指定app启动时必须加载的stroyboard。当此设置存在时，<strong>UIApplication</strong>为加载相同名字的storyboard文件，自动实例化storyboard里的”Initial View Controller“，然后将controller的视图加到<strong>UIWindow</strong>里面 。<br>你也可以在通用栏和<strong>Deployment Info</strong>部分里看到这个项目设置。</p>
<p><img src="/2017/06/27/storyboard教程：上/ProjectSettingsMain.png" alt=""></p>
<p>下面就通过几个view controller来创建一个真正的评分app吧。</p>
<h2 id="添加到我的选项卡"><a href="#添加到我的选项卡" class="headerlink" title="添加到我的选项卡"></a>添加到我的选项卡</h2><p>你将要创建的评分app是一个带有两个屏幕的tab式app。通过stroryboard创建tab很容易。<br>回到<strong>Main.storyboard</strong>然后删除之前创建的view controller。可以通过点击Document Outline的<strong>View Controller</strong>，并点击删除键来完成。<br>拉取对象库里的<strong>Tab Bar Controller</strong>到我们的storyboard里。可以先最大化你的Xcode，因为<strong>Tab Bar Controller</strong>会附带两个view controller，你需要更多的空间来操作。双击屏幕就能放大或者缩小屏幕，或者屏幕来选择伸缩等级。<br>为了方便，再次改变模拟尺寸为iphone大小。方法同上面讲的一样。操作完了之后，附带的两个view controller的也会模拟iphoe6或6s的大小。</p>
<p><img src="/2017/06/27/storyboard教程：上/TabBarController.png" alt=""></p>
<p>Tab Bar Controller 预先定义了两个额外的view controller，一个选项卡对应一个。因为<strong>UITabBarController</strong>包含了一个以上的view controller，所以也被称为<strong>container view</strong>。<strong>Navigation Controller</strong>和<strong>Split View Controller</strong>也是常见的容器。（你等会会用到Navigation Controller的）。<br>容器关系由Tab Bar Controller和view controller之间的箭头表现。特定的嵌入关系是由下图箭头中间可见的图标表示的。</p>
<p><img src="/2017/06/27/storyboard教程：上/12_sb_containment.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>:如果你想要一起移动Tab Bar和它关联的view controller的话，缩小屏幕，选中所有的场景。那么你就可以一起移动它们了。（选中的场景会有一个很细的蓝边框。）</p>
</blockquote>
<p>拉取一个label到第一个view controller（当前标题为“Item 1”），双击它，输入“First Tab”。同样的拉取一个label到第二个view controller（“Item 2”）然后输入“Second Tab”。这样你就能知道选项卡确实在切换了。</p>
<blockquote>
<p><strong>注意</strong>:屏幕缩小的时候不能拉取控件，你需要先通过双击画面来恢复会屏幕的正常尺寸。</p>
</blockquote>
<p>点击Build和Run，你会看到控制台输出一些类似的东西：<br><strong>Ratings[18955:1293100] Failed to instantiate the default view controller for UIMainStoryboardFile “Main” - perhaps the designated entry point is not set?</strong><br>错误非常清晰，你没有设置一个entry point。意思就是你在删除之前的场景后没有设置新的初始控制器。为了解决这个问题，选中Tab Bar Controller，在<strong>Attributes Inspector</strong>。勾选<strong>Is Initial View Controller</strong>栏。</p>
<p><img src="/2017/06/27/storyboard教程：上/InitialViewController.png" alt=""></p>
<p>之前指向被删除的view controller的箭头现在应该指向Tab Bar Controller：</p>
<p><img src="/2017/06/27/storyboard教程：上/13_sb_initialcontroller2.png" alt=""></p>
<p>这就意味着当你运行app时，<em>UIApplication</em>会把Tab Bar Controller作为主屏幕。尝试运行一下app。现在这个app有个选项栏，你可以在选项卡上切换两个view controllers了。</p>
<p><img src="/2017/06/27/storyboard教程：上/SimulatorAppWithTabs.png" alt=""></p>
<blockquote>
<p><strong>小提示</strong>：你可以直接拉取初始箭头到其他view controller来切换初始控制器。</p>
</blockquote>
<p>Xcode实际上自带了一个选项卡式app模板（不出意外的就叫做”Tabber Application template“），但是了解它是如何创建出来也是挺好的，这样你就可以自己创建一个Tab Bar Controller了。</p>
<blockquote>
<p><strong>注意</strong>：如果一个Tab Bar Controller连接了超过5个场景，它会自动生成一个<strong>More…</strong>选项卡，非常整洁。</p>
</blockquote>
<h2 id="加入Table-View-Controller"><a href="#加入Table-View-Controller" class="headerlink" title="加入Table View Controller"></a>加入Table View Controller</h2><p>Tab Bar Controller现在连接的两个view controller是普通的<strong>UIViewController</strong>实例。现在你需要把第一个选项卡切换成<strong>UITableViewController</strong>。<br>在Document Outline里删除第一个view controller。在对象库里拉取一个新的<strong>Table View Controller</strong>到view controller原来的位置上。</p>
<p><img src="/2017/06/27/storyboard教程：上/AddTableViewController.png" alt=""></p>
<p>现在将Table View Controller嵌套进navigation controller里。选中Table View Controller，依次选中Xcode菜单栏里的<strong>Editor\Embed In\Navigation Controller</strong>。这样就会加入一个新的controller：</p>
<p><img src="/2017/06/27/storyboard教程：上/NavigationController.png" alt=""></p>
<p>你也可以从对象库里拉取Navigation Controller然后包裹tableview。但是通过嵌套命令能节省很多时间。<br>由于Navigation也是一个container view controller（就像Tab Bar Controller一样），他也有一个关系箭头指向Table View Controller。你可以在Document Outline里看到这种关系：</p>
<p><img src="/2017/06/27/storyboard教程：上/Relationship.png" alt=""></p>
<p>你会发现Table View Controller多了一个导航条，界面生成器自动创建了它因为现在这个场景现在会在Navigation Controller的框架下展示。这只是一个模拟对象，而并不是一个真正的<strong>UINavigationBar</strong>对象。Simulated Metrics 会推断场景，当场景在Navigation Controller里显示导航栏，当场景在Tab Bar Controller里显示选项条，等等。<br>新的controller现在又是方形的。将它包裹进Tab Bar Controller里这样它就会改变自己的尺寸来适配父场景。<br>按住ctrl键并按住鼠标，从Tab bar Controller拉到Navigation Controller来连接两个场景。当你松开鼠标后，一个小的弹出菜单出现了，选择<strong>Relationship Segue - view controllers</strong>选项：</p>
<p><img src="/2017/06/27/storyboard教程：上/EmbedVC1.gif" alt=""></p>
<p>这样我们就在两个场景之见连成线了。这也是一个包含关系，跟Tab Bar Controller包含其他控制器一样。<br>Tab Bar Controller现在有两个嵌套关系了。一个是选项卡的关系。Navigation Controller和Table View Controller之间也是一个嵌套关系。<br>但你创建了这个新的连接之后，Tab Bar Controller多了一个”Item“选项。对于这个app，你想把这个新的场景作为第一个选项栏，所以拖动tab来改变它们的顺序：</p>
<p><img src="/2017/06/27/storyboard教程：上/Drag-tab-items.gif" alt=""></p>
<p>试着运行一个app，现在第一个选项栏包含一个包裹在navigation controller里面的tableview controller。</p>
<p><img src="/2017/06/27/storyboard教程：上/SimulatorFirstTabWithTableView.png" alt=""></p>
<p>在你加入一个功能之前，你需要先清理一下stroyboard。将第一个选项栏命名为”Players“，第二个命名为”Gestures“。不要在Tab Bar Controller上修改名字，在与这些选项相连的view controller上修改。<br>一旦你连接view controller到Tab Bar Controller上，它就会得到一个<strong>Tab Bar Itme</strong>对象，你可以在Document Outline上或该scene底部看到。你可以在这个Tab Bar Item上配置显示在Tab Bar Controller上的标题和图片。<br>选中Navigation Controller里面的Tab Bar Item，然后在它的Attributes inspector上设置标题为<strong>Players</strong>：</p>
<p><img src="/2017/06/27/storyboard教程：上/TabBarPlayers.png" alt=""></p>
<p>以同样的方式将第二个选项卡命名为<strong>Gestures</strong>。<br>一个好看的app也该也放点图片在这些选项卡上，<a href="https://koenig-media.raywenderlich.com/uploads/2015/08/StoryboardResources.zip" target="_blank" rel="external">resources for this tutorial</a>有个叫做Images的文件夹，将这个目录加到项目里的<strong>Assets.xcassets</strong>子文件夹下。<br>回到<strong>Main.storyboard</strong>，在player这个选项卡的<strong>Attributes inspector</strong>下，选择<strong>Player.png</strong>图片。</p>
<p><img src="/2017/06/27/storyboard教程：上/PlayersImage.png" alt=""></p>
<p>同样的，给Gestures选项卡设置<strong>Gestures.png</strong>图片。<br>嵌套在Navigation Controller下的view controller有<strong>Navigation Item</strong>用来配置导航条。在Document Outline里选中Table View Controller的Navigation Item，然后在Attributes inspector中将标题改为<strong>Players</strong>。</p>
<p><img src="/2017/06/27/storyboard教程：上/NavigationItem.png" alt=""></p>
<p>Document Outline里的scene标题也会变成<strong>Players</strong>。</p>
<blockquote>
<p>你也可以双击导航栏然后在导航栏上修改标题。注意你应该双击在Table View Controller里的导航栏，而不是在Navigation Controller里的Navigation Bar对象。<br>运行app然后惊叹于漂亮的tab bar吧，你没写一行代码就创建了它。</p>
</blockquote>
<p><img src="/2017/06/27/storyboard教程：上/AppWithTabBarImages.png" alt=""></p>
<h2 id="Prototype-Cells"><a href="#Prototype-Cells" class="headerlink" title="Prototype Cells"></a>Prototype Cells</h2><p>prototype cells能让你直接在storyboard编辑栏里很简单的设计cell的自定义布局。<br>Table View Controller自带一个空白的prototype cell。选中这个cell然后在<strong>Attributes inspector</strong>将<strong>Style</strong>选项设置为<strong>Subtitle</strong>。cell的外观马上就改变了，现在包含了两个label。</p>
<blockquote>
<pre><code>由于在storyboard中可能有很多可堆叠的内容，有时候你很难点中你想点中的对象。如果遇到困难了，可以使用以下几个方法。第一个就是点击画面左边的Document Outline。第第二方法就是使用快捷键：同时按住control和shift，然后点击你想点的区域。一个弹框就会出现，你可以在那选中任何你想的元件。
</code></pre></blockquote>
<p>如果你之前手动创建使用过table view，你可能会知道<strong>UITableViewCellStyle.Subtitle</strong>这个类型。通过protorype cell，你可以像刚才一样选择一个内置的cell样式，或者创建你自己的定制设计（你等下很快就会做）。<br>设置<strong>Accessory</strong>为<strong>Disclosure Indicator</strong>，在<strong>Idenrifier</strong>输入<strong>PlayerCell</strong>。每个prototype cell都用有重用标识，这样你才能在代码中引用它。</p>
<p><img src="/2017/06/27/storyboard教程：上/CellSetup.png" alt=""></p>
<p>运行app，然后。。。什么都没有发生。这没什么奇怪的：你还没有设置table的数据源呢，所以它根本不知道没行应该显示什么。设置数据源就是我们接下来要做的了。<br>在这个项目中加入一个新的文件。选在iOS/Source下的<strong>Cocoa Touch Class</strong>模板。命名为<strong>PlayersViewController</strong>，设置为<strong>UITablViewController</strong>的子类。去掉<strong>Also creat XIB file</strong>。选择<strong>swift</strong>语言，点击<strong>Next</strong>来创建它。</p>
<p><img src="/2017/06/27/storyboard教程：上/PlayersViewController.png" alt=""></p>
<p>回到storyboard选择Table View Controller（确定你选中的是view controller而不是它里面的view）。在<strong>Identity inspector</strong>，选择<strong>Class</strong>为<strong>PlayersViewController</strong>。这是连接上storyboard里的scene和你的自定义view controller必不可少的步骤。千万别忘了这一步不然你的类不会被使用到。</p>
<p><img src="/2017/06/27/storyboard教程：上/PlayersVCClass.png" alt=""></p>
<p>从现在起，当你运行app，storyboard里的table view controller就是<strong>PlayersViewController</strong>类的实例了。<br>这个表格应该显示选手的列表，所以你需要创建一个数据模型，它应该是一个包含了选手对象的数组。使用iOS/Source下的<strong>Swift File</strong>模板来添加一个新文件，命名为”Player“。<br>将<em>Player.swift</em>下的代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">struct Player &#123;</div><div class="line">  var name: String?</div><div class="line">  var game: String?</div><div class="line">  var rating: Int</div><div class="line">  </div><div class="line">  init(name: String?, game: String?, rating: Int) &#123;</div><div class="line">    self.name = name</div><div class="line">    self.game = game</div><div class="line">    self.rating = rating</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里没什么特别的。<strong>Player</strong>仅仅是玩家名字，玩的游戏以及1到5个星的等级三个属性的容器对象。<br>接下来创建一个测试用的<strong>Player</strong>对象数组然后赋值到<strong>PlayersViewController</strong>里的array上。使用<strong>Swift File</strong>模板创建一个新文件，命名为<strong>SampleData</strong>，在<strong>SampleData.swift</strong>里加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let playersData = [ </div><div class="line">  Player(name:&quot;Bill Evans&quot;, game:&quot;Tic-Tac-Toe&quot;, rating: 4),</div><div class="line">  Player(name: &quot;Oscar Peterson&quot;, game: &quot;Spin the Bottle&quot;, rating: 5),</div><div class="line">  Player(name: &quot;Dave Brubeck&quot;, game: &quot;Texas Hold &apos;em Poker&quot;, rating: 2) ]</div></pre></td></tr></table></figure>
<p>现在已经定义个了个叫做palyersData的常量，并赋值给它由一些写死的对象所组成的数组。<br>现在在<strong>PlayersViewController.swift</strong>里的<strong>class PlayersTableViewController： UITableViewController</strong>下添加一个数组属性来持有这个选手列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var players:[Player] = playersData</div></pre></td></tr></table></figure>
<p>在定义<strong>palyers</strong>的时候，你可以先很简单的写好几个样本数据。但是因为这个数据之后有可能由plist或者SQL文件提供，最好还是在<strong>PlayerViewController</strong>之外处理加载这些数据。<br>现在你已经有了装满了<strong>Player</strong>对象的数组了，你可以继续获取数据源了。还是在<strong>PlayersViewControlelr.swift</strong>里，用下面的代码来替换data souce方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;</div><div class="line">  return 1</div><div class="line">&#125;</div><div class="line">  </div><div class="line">override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class="line">  return players.count</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正的业务发生在<strong>cellForRowAtIndexPath</strong>里。用下面的代码替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</div><div class="line"> -&gt; UITableViewCell &#123;</div><div class="line">  let cell = tableView.dequeueReusableCellWithIdentifier(&quot;PlayerCell&quot;, forIndexPath: indexPath)</div><div class="line">    </div><div class="line">  let player = players[indexPath.row] as Player</div><div class="line">  cell.textLabel?.text = player.name</div><div class="line">  cell.detailTextLabel?.text = player.game</div><div class="line">  return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>dequeueReusableCellWithIdentifier(_:forIndexPath:)</strong>会检查是否有能重用的cell。如果没有的话，它会自动分配一个prototype返回给你。所有你需要做的是在storyboard编辑器中提供您在prototype上设置的重用标识符 - 在本例中为<strong>PlayerCell</strong>。不要忘记设置该标识符，否则这个小方案将无法正常工作！<br>运行这个app，好好瞧一瞧，table view现在有选手在里面了！</p>
<p><img src="/2017/06/27/storyboard教程：上/AppWithPlayers.png" alt=""></p>
<p>只有了几行代码就使用了prototype cells。我觉得这真的太棒了。</p>
<blockquote>
<p><strong>注意</strong>：在这个app中你只使用了一种prototype cell，但是如果你想显示更多不同类型的cell，那你只需要在storyboard中很简单的添加另外的prototype cell。你可以复制现有的cell来创建一个新的，或者增加Table View的Prototype Cells属性的值。但是一定要记住给每个cell自己的重用标识符。</p>
</blockquote>
<h2 id="设计你自己的Prototype-Cell"><a href="#设计你自己的Prototype-Cell" class="headerlink" title="设计你自己的Prototype Cell"></a>设计你自己的Prototype Cell</h2><p>对于很多app来说，使用标准的cell类型没什么问题，但在这个app上你想要在cell的右边加上图片来显示选手的评分（1到5星）。标准类型不支持在那个位置放图片，所以你需要自己来设计一个类型。<br>切换回<strong>Main.storyboard</strong>，选中tableivew中的prototype cell，在<strong>Attributes inspector</strong>设置<strong>Style</strong>属性为<strong>Custom</strong>。这样默认的label就消失了。<br>首先增加cell的高度。直接更改<strong>Size inspector</strong>中的<strong>Row Height</strong>值为60或者拖动cell的底部来拉高至60。<br>在对象库中拉取拉两个label对象到cell中，位置就跟之前的标准样式label的位置大致一样就可以了。使用Attributes Inspectror来设置你喜欢的字体和颜色。上面的label设置文字为<strong>Name</strong>，下面的label设置<strong>Game</strong>。<br>在Document Outline按住Command+click按同时选择两个label，然后依次点击<strong>Editor\Embed In\Stack View</strong>。</p>
<blockquote>
<p><strong>注意</strong>：Stack view是iOS9新推出，可以帮助你更方便的布局页面集。</p>
</blockquote>
<p>拉取一个<strong>Image View</strong>到cell中并放置在右边，靠在disclosure indicator旁边。在Size Inspector中，设置宽为81，高35。设置<strong>Mode</strong>为<strong>Center</strong>（就在Attributes inspector）下面，这样你不管你放任何图片image view都不会被拉伸。<br>按住command+click在Document Outline来选中Stack View和Image View。依次点击<strong>Editor\Embed in\Stack View</strong>。Xcode会创建一个新的包含这两个控件的水平stack view。</p>
<p><img src="/2017/06/27/storyboard教程：上/StackView.png" alt=""></p>
<p>选中新的stack view，在Attributes Inspecrot中，改变Alignment为<strong>Centre</strong>，Distribution为<strong>Equal Spacing</strong>。</p>
<p>接下来为这个控件加一些简单的布局。在storyboard的右下角，点击如下图标：</p>
<p><img src="/2017/06/27/storyboard教程：上/PinIcon.png" alt=""></p>
<p>设置约束为Top：<strong>0</strong>，Right：<strong>20</strong>，Bottom：<strong>0</strong>，Left：<strong>20</strong>。确保四个指向这些值的红色指针如图所示高亮显示。点击窗口下面的<strong>Add 4 Constraints</strong>。</p>
<p><img src="/2017/06/27/storyboard教程：上/Constraints.png" alt=""></p>
<p>如果你的stack view有橙色的约束，那就是发错位置了。为了解决这个问题，选中stack view依次选择<strong>Editor\Resolve Auto Layout Issues\Update Frames</strong>。stack view的摆放位置应该就会正确了，橙色的约束错误也会消失。<br>要将image view正确摆放在stack view中，选择Document Outline中的image view依次选择<strong>Editor\Resolve Auto Layout Issues\Add Missing Constraints</strong>。<br>prototype cell最后看上去应该像这样子：</p>
<p><img src="/2017/06/27/storyboard教程：上/FinalCell.png" alt=""></p>
<p>因为这是一个自定义cell，你不能再使用<strong>UITableview</strong>的<strong>textLabel</strong>和<strong>detailTextLabel</strong>属性来输入文字到这些label中了。这两个属性指向的label现在并不在这个cell。你只能在标准cell类型中使用这些属性。相应的，你可以使用tag来找到这些label。</p>
<blockquote>
<p>Tag只是为了简单才在这里使用的。在下面的教程中你会创建一个继承自UITbaleViewCell的自定义类来包含这些label相关联的属性。</p>
</blockquote>
<p>在Arrtibutes inspector中设置<strong>Name</strong>label的tag值为100，<strong>Game</strong>label为101，<strong>Image View</strong>为102.<br>接着打开<strong>PlayersViewController.swift</strong>，添加一个名为<strong>imageForRating</strong>的新方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func imageForRating(rating:Int) -&gt; UIImage? &#123;</div><div class="line">  let imageName = &quot;\(rating)Stars&quot;</div><div class="line">  return UIImage(named: imageName)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单。这个方法根据不同的评级返回不同的星级图片。还是在PalyersViewController中，像下面这样改变<strong>tableView(_:cellForRowAtIndexPath:)</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class="line">  let cell = tableView.dequeueReusableCellWithIdentifier(&quot;PlayerCell&quot;, forIndexPath: indexPath) //1</div><div class="line">    </div><div class="line">  let player = players[indexPath.row] as Player //2</div><div class="line">  </div><div class="line">  if let nameLabel = cell.viewWithTag(100) as? UILabel &#123; //3</div><div class="line">    nameLabel.text = player.name</div><div class="line">  &#125;</div><div class="line">  if let gameLabel = cell.viewWithTag(101) as? UILabel &#123;</div><div class="line">    gameLabel.text = player.game</div><div class="line">  &#125;</div><div class="line">  if let ratingImageView = cell.viewWithTag(102) as? UIImageView &#123;</div><div class="line">    ratingImageView.image = self.imageForRating(player.rating)</div><div class="line">  &#125;</div><div class="line">  return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法主要做了这几件事情：</p>
<ol>
<li><strong>dequeueReusableCellWithIdentifier</strong>会根据reuse identifier来重用cell 或者创建一个新的cell。</li>
<li>查找与要操作的cell行数对应的<strong>Player</strong>对象并赋值给<strong>player</strong>。</li>
<li>通过label和image的tag来找到它们并将<strong>palyer</strong>对象中的数据填充进去。</li>
</ol>
<p>现在再次运行app，它看上去应该像这样子：</p>
<p><img src="/2017/06/27/storyboard教程：上/WrongCellHeight.png" alt=""></p>
<p>呃😓，看上去好像不怎么对，cell像是被压扁了一样。你确实改过prototype的高度了，但是table view并没有使用到。这里有两个方法来修复它：你可以修改table view的<strong>Row Height</strong>属性，或者实现<em>tableView(tableView:heightForRowAtIndexPath:) </em>方法。在这个例子中第一种的方法比较好，因为我们只有一种类型的cell并且我们提前知道了高度。</p>
<blockquote>
<p><strong>注意</strong>:如果你没有提前知道cell的高度或者不同行的cell有不同的高度，你应该使用<strong>tableView(tableView:heightForRowAtIndexPath:)</strong>方法。</p>
</blockquote>
<p>回到<strong>Main.storyboard</strong>,在Table View的<strong>Size inspector</strong>中，设置<strong>Row Height</strong>为60：</p>
<p><img src="/2017/06/27/storyboard教程：上/RightHeight1.png" alt=""></p>
<p>再运行一次app，现在看上去好多了！</p>
<p><img src="/2017/06/27/storyboard教程：上/AppProperRowHeight.png" alt=""></p>
<p>顺便说一下，如果你之前是通过拖拽cell来改变高度而不是直接输入高度的话，那么table view的Row Height也会自动修改。所以你可能第一次运行的时候就显示正确了。</p>
<h2 id="使用Cell的子类"><a href="#使用Cell的子类" class="headerlink" title="使用Cell的子类"></a>使用Cell的子类</h2><p>table view已经正常显示了，但是我不太喜欢使用tag来访问label和其他prototype cell的子视图。如果你可以将这些标签连接到代码，然后使用相应的属性，那将会更加清晰。事实证明，你可以。<br>在项目中加入新的文件，使用<strong>Cocoa Touch Class</strong>模板。命名为<strong>PlayerCell</strong>并继承自<strong>UITableViewCell</strong>，不要勾选创建XIB这个选项，因为你在storyboard中一句有了这个cell了。<br>在<strong>PlayerCell</strong>类中加入以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@IBOutlet weak var gameLabel: UILabel!</div><div class="line">@IBOutlet weak var nameLabel: UILabel!</div><div class="line">@IBOutlet weak var ratingImageView: UIImageView!</div></pre></td></tr></table></figure>
<p>这些变量都是<strong>IBOutlets</strong>，可以连接到stroyboard中的scene。<br>将此属性添加到IBOutlets下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var player: Player! &#123;</div><div class="line">  didSet &#123;</div><div class="line">    gameLabel.text = player.game</div><div class="line">    nameLabel.text = player.name</div><div class="line">    ratingImageView.image = imageForRating(player.rating)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当设置<strong>player</strong>属性的时候，它就会更新这个IBOutlets的数据。<br>将PlayersViewController中的<strong>imageForRating(_:)</strong>移到<strong>PlayerCell</strong>类中，以保持cell实现细节相同。<br>回到<strong>Main.storyboard</strong>，选择<strong>PlayerCell</strong>在<strong>Identity inspector</strong>中改变class属性为<strong>PlayerCell</strong>。这样当你用<strong>dequeueReusableCellWithIdentifier(_:forIndexPath:)</strong>来请求重用cell时，它会返回<strong>PlayerCell</strong>实例而不是<strong>UITableViewCell</strong>实例了。<br>注意你的reuse identifier跟这个类的名字相同，都叫做<strong>Player Cell</strong>。但这只是因为我喜欢保持它们一致。类名和reuse identifier之间没什么关联，所以你可以用不同的名字来命名它们。<br>现在将label和image连接到这些outlet上。在storyboard移动到<strong>Connections Inspector</strong>中，并在画面或Document Outline中选中<strong>Player Cell</strong>。将Connections inspecrot中的<strong>nameLabel</strong>Outlet拉到Documet Outline的<strong>Name</strong>label对象。<strong>gameLabel</strong>和<strong>ratingImageView</strong>也是同样的操作。</p>
<p><img src="/2017/06/27/storyboard教程：上/NameLabel.gif" alt=""></p>
<blockquote>
<p><strong>重点</strong>:你应该将控件连接到table view cell里，而不是view controller里面！你可以看到，无论何时数据源使用<strong>dequeueReusableCellWithIdentifier</strong>向table view请求新的cell，tableview不会给你实际的prototype cell，但是可以复制一个副本（或者是之前回收的cell）。<br> 这意味着在任何给定的时间都将有不止一个<strong>PlayerCell</strong>实例。如果要将label从cell连接到view controller上的outlet上，那么label的几个复制副本将会使用相同的outlet。这会造成麻烦。（另一方面，将prototype cell连接到view controller上实现的方法是挺好的，如果你的cell上有自定义按钮或其他控件，则可以这样做）。</p>
</blockquote>
<p>连接了这些属性之后，你可以简化一下数据源的代码。在<strong>PlayersViewController</strong>，改变<strong>tableView(_:cellForRowAtIndexPath:)</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</div><div class="line">    -&gt; UITableViewCell &#123;</div><div class="line">    let cell = tableView.dequeueReusableCellWithIdentifier(&quot;PlayerCell&quot;, forIndexPath: indexPath)</div><div class="line">        as! PlayerCell</div><div class="line">      </div><div class="line">    let player = players[indexPath.row] as Player</div><div class="line">    cell.player = player</div><div class="line">    return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去好多了。现在，你将从dequeueReusableCellWithIdentifier收到的对象转换为PlayerCell，然后可以简单得将正确的player对象传递到cell中。<br>在PlayerCell中设置player变量将自动将值设置到label和image view中，cell将使用你在storyboard中连接的IBOutlets。使用prototype cell使table view的使用少了很多麻烦事。<br>再次运行app。它看上去应该跟之前一样，但是在场景后面我们现在使用的是自己的table view cell子类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="蒋正义" />
          <p class="site-author-name" itemprop="name">蒋正义</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蒋正义</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
